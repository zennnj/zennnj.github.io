<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->
<!-- keywords -->
<head><!-- hexo injector head_begin start --><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="">
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    <meta name="description" content="">
    <meta name="description" content="总之来玩玩，感觉和java区别没有很大">
<meta property="og:type" content="article">
<meta property="og:title" content="C#">
<meta property="og:url" content="http://example.com/posts/59760.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="总之来玩玩，感觉和java区别没有很大">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-10-25T05:57:01.000Z">
<meta property="article:modified_time" content="2024-11-09T10:00:21.972Z">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/my.ico">
    <title>C# · Terminal 4</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .footer-fixed-btn,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(
            -45deg,
            #444 0,
            #444 80px,
            #333 80px,
            #333 160px
        );
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link id="stylesheet-fancybox" rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-base" rel="preload" href="/css/style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-mobile" rel="preload" href="/css/mobile.css" as="style" onload="this.onload=null;this.rel='stylesheet';this.media='screen and (max-width: 960px)'">
    <link id="stylesheet-theme-dark" rel="preload" href="/css/dark.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    <!-- 百度统计  -->
    <!-- 谷歌统计  -->
    <!-- Google tag (gtag.js) -->
<style type="text/css">
.spoiler {
  display: inline;
}
p.spoiler {
  display: flex;
}
.spoiler a {
  pointer-events: none;
}
.spoiler-blur, .spoiler-blur > * {
  transition: text-shadow .5s ease;
}
.spoiler .spoiler-blur, .spoiler .spoiler-blur > * {
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  text-shadow: 0 0 10px grey;
  cursor: pointer;
}
.spoiler .spoiler-blur:hover, .spoiler .spoiler-blur:hover > * {
  text-shadow: 0 0 5px grey;
}
.spoiler-box, .spoiler-box > * {
  transition: color .5s ease,
  background-color .5s ease;
}
.spoiler .spoiler-box, .spoiler .spoiler-box > * {
  color: black;
  background-color: black;
  text-shadow: none;
}</style><meta name="generator" content="Hexo 7.3.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
        <body class="post-body">
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        <div class="header-sidebar-menu">
            <div style="padding-left: 1px;">&#xe775;</div>
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href="/">Terminal 4.</a>
        </span>
    </div>
    <!-- toggle banner -->
    <div class="banner">
        <div class="blog-title header-element">
            <a href="/">Terminal 4.</a>
        </div>
        <div class="post-title header-element">
            <a href="#" class="post-name">C#</a>
        </div>
    </div>
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- donate button -->
    <div class="donate-popup donate-popup--hidden">
    <div class="donate-popup__title">Buy Me A Milktea!</div>
    <div class="donate-popup__content">
        <div class="donate-popup__content-description">If this post helped you, please consider buying the author a cup of milktea 🥤!(Actually,I prefer fruit tea.🥳)</div>
        <img
            class="donate-popup__content-qrCode"
            title="Wechat"
            alt="Wechat"
            src="/assets/donate-wechat.png"
        ></img>
        <img
            class="donate-popup__content-qrCode"
            title="Alipay"
            alt="Alipay"
            src="/assets/donate-alipay.jpg"
        ></img>
    </div>
</div>

    <div
        title="Donate to the author"
        class="footer-fixed-btn footer-fixed-btn--hidden donate-btn"
    >
        <i class="fas fa-donate"></i>
    </div>

    <!-- back to top button -->
    <div class="footer-fixed-btn footer-fixed-btn--hidden back-top">
        <div>&#xe639;</div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="    height:50vh;
">
    <!-- 主页  -->
    <!-- 404页  -->
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
                C#
            <!-- 404 -->
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            <!-- 404 -->
        </p>
        <!-- 文章页 meta -->
            <div class="post-intros">
                <!-- 文章页标签  -->
                    <div class="post-intro-tags" >
        <a class="post-tag" href="javascript:void(0);" data-tags="learn">learn</a>
</div>

                <!-- 文章字数统计 -->
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2024/10/25</span>
                    <!-- busuanzi -->
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" alt="loading">
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>总之来玩玩，感觉和java区别没有很大<br><span id="more"></span><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BreezeJDK/p/16739052.html">C#语法随记——Event?.Invoke()</a></p>
<h1 id="控制台输入输出"><a href="#控制台输入输出" class="headerlink" title="控制台输入输出"></a>控制台输入输出</h1><p><code>Console.WriteLine(&quot;&quot;);</code><br><code>Console.Write(&quot;&quot;);</code><br><code>Console.ReadLine();</code>直到回车<br><code>Console.ReadKey();</code>吃一个按键的内容</p>
<hr>
<h1 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h1><p>关键字<code>const</code></p>
<h2 id="值和引用类型"><a href="#值和引用类型" class="headerlink" title="值和引用类型"></a>值和引用类型</h2><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>string，数组，类</p>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>其他，结构体</p>
<hr>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p><code>string str=&quot;ww\&#39;&quot;</code><br><code>\</code><br><code>\a</code>警报音 &lt;-这个好玩</p>
<hr>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><p><code>(int)str</code></p>
<h2 id="Parse"><a href="#Parse" class="headerlink" title="Parse"></a>Parse</h2><p>只能转字符串<br><code>int.Parse(&quot;123&quot;)</code></p>
<h2 id="Convert"><a href="#Convert" class="headerlink" title="Convert"></a>Convert</h2><p><code>Convert.To目标类型(变量/常量)</code></p>
<h2 id="转String"><a href="#转String" class="headerlink" title="转String"></a>转String</h2><p><code>.toString();</code></p>
<hr>
<h1 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    ..</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    ..</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> E_MonsterType&#123;</span><br><span class="line">    Normal,<span class="comment">//0</span></span><br><span class="line">    Boss,<span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>可以说和java一模一样</p>
<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><p><code>int[,] arr = new int[3,3]</code></p>
<h2 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h2><p><code>int[][] arr = new int[3][]&#123;new int[]&#123;1,2,3,4,5&#125;,new int[]&#123;1&#125;,new int[]&#123;2,2&#125;&#125;</code> </p>
<hr>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="ref和out"><a href="#ref和out" class="headerlink" title="ref和out"></a>ref和out</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangValueRef</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ChangValueRef</span>(<span class="params"><span class="keyword">out</span> <span class="built_in">int</span> <span class="keyword">value</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">value</span> = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数参数的修饰符<br>当传入的值类型蚕食在内部修改时 或者引用类型参数在内部重新声明时<br>外部的值会发生变化</p>
<ol>
<li>ref传入的变量必须初始化 out不用</li>
<li>out传入的变量必须在内部赋值 ref不用<h2 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h2>变长参数关键字<code>params</code><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//static int sum(int a, int b,int c....)</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">sum</span>(<span class="params"><span class="built_in">string</span> name,<span class="keyword">params</span> <span class="built_in">int</span>[] arr</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.Length;i++)&#123;</span><br><span class="line">        sum+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>&#123;</span><br><span class="line">    Sum(<span class="string">&quot;lala&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>params 关键字后必须是数组</li>
<li>数组的类型可以是任意的类型</li>
<li>函数参数中只能最多出现一个params关键字 并且一定是在最后一组参数，前面可以有n个其他参数<h2 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak</span>(<span class="params"><span class="built_in">string</span> str = <span class="string">&quot;你是弱智！&quot;</span></span>)</span>&#123;</span><br><span class="line">    Console.WriteLine(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>可选参数必须在普通参数后面</strong><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2>在同一语句块(class or struct)中<br>函数（方法）名相同，参数的数量/类型不同<br>作用:</li>
<li>减少函数名的数量，避免命名空间的污染</li>
<li>提升程序可读性</li>
</ol>
<p>加ref/out修饰词算改变参数类型（不过不是可行的<br>加默认值不算改变参数</p>
<hr>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>在结构体中可以构造方法<br>在方法中可以直接使用结构体内部的变量</p>
<h2 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h2><p>private public<br><strong>默认不写为private</strong><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> student&#123;</span><br><span class="line">    <span class="built_in">int</span> age;</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span>()</span>&#123;</span><br><span class="line">        Console.WriteLine(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        student s = <span class="keyword">new</span> student();</span><br><span class="line">        <span class="comment">//不用struct student哦o.O</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="结构体的构造函数"><a href="#结构体的构造函数" class="headerlink" title="结构体的构造函数"></a>结构体的构造函数</h2><p>如果声明了构造函数 那么必须在其中对所有变量数据初始化<br><strong>结构体不允许无参构造函数</strong><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Student</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>可以这样↓<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> <span class="title">Student</span>(<span class="params"><span class="built_in">int</span> id, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> id = id;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name = name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span> Student(<span class="number">11</span>,<span class="string">&quot;小明&quot;</span>);</span><br></pre></td></tr></table></figure><br>可以这样↓<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = <span class="keyword">new</span>(<span class="number">11</span>,<span class="string">&quot;小明&quot;</span>);</span><br></pre></td></tr></table></figure><br>感觉就像不能加修饰符，不能继承的class，c里struct的plus版（…</p>
<hr>
<h1 id="类-封装"><a href="#类-封装" class="headerlink" title="类-封装"></a>类-封装</h1><p>在struct里不能声明同名struct<br>但是在class里可以有一个同名class<br>(java的class里也可以，好像可以通过这个手动构造链表，不过java有linkedlist了没必要)<br><strong>如果要在类中声明一个和自己相同类型的成员变量时，不能对他进行实例化</strong></p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><p>默认值：<br>数字类-&gt;0,bool-&gt;false<br>引用类型-&gt;null</p>
<p>public private protected</p>
<p><code>default(变量类型)</code>查看默认值</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>如果不自己实现无参构造函数而实现了有参构造函数<br>会失去默认的无参构造(java里也是！)<br>没有特殊需求(单例模式)时，一般是public的<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span>(<span class="params"><span class="built_in">int</span> age,<span class="built_in">string</span> name</span>):<span class="title">this</span>()</span>&#123;</span><br><span class="line">    <span class="comment">//首先调用无参构造器</span></span><br><span class="line">    <span class="comment">//节约代码量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h2><p><em>当引用类型的堆内存<strong>被回收时</strong>，会调用该函数</em><br>对于需要手动管理内存的语言（比如c++），需要在析构函数中做一些内存回收处理<br>但是在c#中存在自动的垃圾回收机制，所以几乎不怎么使用析构函数<br>除非你想在某一个对象被垃圾回收时，做一些特殊处理<br>注意：<br>在unity开发中构析函数几乎不会使用<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~Person()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="成员属性"><a href="#成员属性" class="headerlink" title="成员属性"></a>成员属性</h2><p>访问修饰符 属性类型 属性名{<br>    get{}<br>    set{}<br>}<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="comment">//在返回之前添加一些逻辑规则</span></span><br><span class="line">            <span class="comment">//意味着这个属性可以获取的内容</span></span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            <span class="comment">//在设置之前添加一下逻辑规则</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">value</span>&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">value</span> = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span>();</span><br><span class="line">p.Name = <span class="string">&quot;米老鼠&quot;</span>;</span><br></pre></td></tr></table></figure><br>value关键字表示外部传入的值<br>提供一种设置getname方法以外改变成员变量值的方法<br>方便使用和修改的同时保持成员的private<br>可以实现加密<br>set和get也可以使用修饰符（要低于属性的访问权限） 不能让get和set的访问权限都低于属性的权限<br>set和get可以只有一个（一般是只有get）</p>
<h3 id="自动属性"><a href="#自动属性" class="headerlink" title="自动属性"></a>自动属性</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">float</span> Height&#123;</span><br><span class="line">    <span class="keyword">set</span>;</span><br><span class="line">    <span class="keyword">get</span>;</span><br><span class="line">    <span class="comment">//在setget中没有特殊处理,节约代码量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="索引器"><a href="#索引器" class="headerlink" title="索引器"></a>索引器</h2><p>让对象可以像数组一样通过索引器访问其中元素，让程序看起来更直观，更容易编写<br>以中括号的形式访问自定义类中的元素，规则自己定<br>比较适用于在类中有数组时实用<br>索引器可以重载<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person[] friends;</span><br><span class="line">    <span class="keyword">public</span> Person <span class="keyword">this</span>[<span class="built_in">int</span> index]&#123;</span><br><span class="line">        <span class="keyword">get</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> friends[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span>&#123;</span><br><span class="line">            friends[index] = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span>();</span><br><span class="line">p[<span class="number">0</span>] = <span class="keyword">new</span> Person(); </span><br></pre></td></tr></table></figure><br>可以通过索引器来达成hashmap/dictionary的效果<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">string</span> str]&#123;<span class="comment">//参数填n个也是没问题的</span></span><br><span class="line">    <span class="keyword">get</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(str)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;name&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;age&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.age.ToString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h2><p>为什么可以直接点出来使用：<br>类加载时就加载<br>直到程序结束才会被释放</p>
<h3 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h3><p>静态成员粽不能使用非静态成员<br>非静态成员可以使用静态成员<br>过多静态成员会造成频繁gc-&gt;程序卡顿<br>const(常量)可以理解为特殊的static<br>相同点：都可以通过类名点使用<br>不同点：</p>
<ol>
<li>const必须初始化，不能被修改</li>
<li>const只能修饰变量</li>
<li>const一定写在访问修饰符后面</li>
</ol>
<h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>只能包含静态成员<br>不能被实例化（纯工具） console就是一个静态类<br>(java中没有静态类，但是有abstract)</p>
<h3 id="静态构造函数"><a href="#静态构造函数" class="headerlink" title="静态构造函数"></a>静态构造函数</h3><p>不能有访问修饰符 不能有参数 只会自动调用一次<br>主要用来初始化静态成员变量<br>（java里不能）<br>如果同一个类实例化了两次，静态构造函数会只调用一次（第一次实例化的时候）</p>
<h2 id="拓展方法"><a href="#拓展方法" class="headerlink" title="拓展方法"></a>拓展方法</h2><p>为现有的非静态变量类型添加新方法<br>一定是写在静态类中，一定是个静态函数<br>第一个参数为拓展目标 第一个参数用this修饰<br>如果拓展方法和原方法重名了，则使用原方法<br>作用：</p>
<ol>
<li>提升程序拓展性</li>
<li>不需要再对象中重写方法，为别人封装的类型写额外的方法</li>
<li>不需要继承来添加方法</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Tools</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//为int拓展了一个成员方法</span></span><br><span class="line">    <span class="comment">//value代表使用该方法实例化对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SpeakValue</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">int</span> <span class="keyword">value</span>,strring str</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//拓展方法的使用</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> i=<span class="number">10</span>;</span><br><span class="line">i.SpeakValue(<span class="string">&quot;这是传进去的参数&quot;</span>);<span class="comment">//i就是value</span></span><br></pre></td></tr></table></figure>
<p>实际上写一个函数把i传进去也一样吧(….)<br>只不过是可以写.方法()了</p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>算数运算符，逻辑运算符（只有!可以），位运算符，条件运算符都可以被重载<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> +(Point p1,Point p2)&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point();</span><br><span class="line">        p.x = p1.x+p2.x;</span><br><span class="line">        p.y = p1.y+p2.y;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Point p = <span class="keyword">new</span>();</span><br><span class="line">p.x=<span class="number">1</span>;</span><br><span class="line">p.y=<span class="number">2</span>;</span><br><span class="line">Point p2 = <span class="keyword">new</span>();</span><br><span class="line">p2.x=<span class="number">6</span>;</span><br><span class="line">p2.y=<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">Point p3 = p + p2;</span><br></pre></td></tr></table></figure></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>使用： class.内部class 变量名</p>
<h2 id="分部类"><a href="#分部类" class="headerlink" title="分部类"></a>分部类</h2><p>把一个类分成几部分声明<br>类的访问修饰符要一致<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">student</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> eye;</span><br><span class="line">    <span class="built_in">int</span> leg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">student</span>&#123;</span><br><span class="line">    <span class="built_in">int</span> head;</span><br><span class="line">    <span class="built_in">int</span> hand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student s = <span class="keyword">new</span>();</span><br></pre></td></tr></table></figure><br>其实比较鸡肋</p>
<h2 id="分部方法"><a href="#分部方法" class="headerlink" title="分部方法"></a>分部方法</h2><p>将方法的声明和实现分离</p>
<hr>
<h1 id="类-继承"><a href="#类-继承" class="headerlink" title="类-继承"></a>类-继承</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>c# 不能多继承<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">teacher</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">teachingteacher</span> : <span class="title">teacher</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>任何父类出现的地方，子类都可以替代<br>语法表现：父类容器装子类对象，因为子类对象包含了父类的所有内容（向上造型）</p>
<h3 id="is-amp-as"><a href="#is-amp-as" class="headerlink" title="is&amp;as"></a>is&amp;as</h3><p>is:判断一个对象是否为指定类对象<br>as:讲一个对象转换为指定对象,失败则返回null<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(player <span class="keyword">is</span> Player)&#123;</span><br><span class="line">    Player p = player <span class="keyword">as</span> Player;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当用父类容器装载子类对象分不清里面是啥的时候使用</p>
<h2 id="继承中的构造器"><a href="#继承中的构造器" class="headerlink" title="继承中的构造器"></a>继承中的构造器</h2><p>父类的父类的构造-&gt;父类的构造-&gt;子类构造<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">son</span>:<span class="title">father</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">son</span>(<span class="params"><span class="built_in">int</span> i</span>):<span class="title">base</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="万物之父"><a href="#万物之父" class="headerlink" title="万物之父"></a>万物之父</h2><p>object</p>
<h3 id="拆箱装箱"><a href="#拆箱装箱" class="headerlink" title="拆箱装箱"></a>拆箱装箱</h3><p><strong>用object存值类型（装箱）</strong><br>-&gt;把值类型用引用类储存，占内存会迁移到堆内存中<br><strong>再把object转为值类型（拆箱）</strong><br>-&gt;把引用用类型存储的值类型取出来，堆内存会迁移到栈内存中<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">object</span> v =<span class="number">3</span>;</span><br><span class="line"><span class="built_in">int</span> intvalue = (<span class="built_in">int</span>)v;</span><br></pre></td></tr></table></figure><br>好处：方便参数的存储传递<br>坏处：内存迁移，增加性能消耗<br>可以实现泛型？</p>
<h2 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h2><p>用<code>sealed</code>修饰的类<br>让类无法被继承</p>
<hr>
<h1 id="类-多态"><a href="#类-多态" class="headerlink" title="类-多态"></a>类-多态</h1><h2 id="vob"><a href="#vob" class="headerlink" title="vob"></a>vob</h2><p>v:virtual(虚函数)<br>o:override<br>b:base<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">game</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">game</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="comment">//虚函数可以被子类重写</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">player</span>:<span class="title">game</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">player</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Atk</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">base</span>.Atk();<span class="comment">//可以通过base来保留父类的行为</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>被abstract修饰的类<br>不能实例化、继承必须重写抽象方法<br>抽象方法没有方法体，不能是私有的</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口命名规范I名字<br>规范：<br><strong>不包含成员变量</strong><br>成员不能实现，即可以写属性，但不能写setget具体方法，留给子类实现<br>接口不能继承类，但可以继承另一个接口，<strong>继承后实现的方法必须是public的</strong><br>接口也符合里氏转换原则<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">Ifly</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">person</span>:<span class="title">animal</span>,<span class="title">Ifly</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="密封方法"><a href="#密封方法" class="headerlink" title="密封方法"></a>密封方法</h2><p><code>sealed</code>修饰<br>不能被重写</p>
<hr>
<h1 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a>结构体和类的区别</h1><p>最大区别在存储空间上，结构体是指，类是引用<br>也如之前的分析，strcut不能继承</p>
<p>对象是数据集合时，优先考虑结构体，比如坐标、位置…<br>经常被赋值，且改变赋值对象，原对象不想跟着变化时，用结构体</p>
<hr>
<h1 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h1><p>抽象类可以有构造函数<br>抽象类只能被单一继承<br>抽象类可以声明成员方法、虚方法、静态方法…<br>抽象类可以使用访问修饰符<br>对象-&gt;类<br>行为-&gt;接口</p>
<hr>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><p>垃圾回收 <code>GC(Garbage Collactor)</code><br>垃圾回收的过程是在遍历堆(Heap)上动态分配的所有对象<br>通过识别他们是否被引用来确定那些对象是垃圾，哪些对象仍要被使用<br>所谓的垃圾就是没有任何变量、对象引用的内容<br>垃圾就需要回收释放</p>
<p>垃圾回收有多种算法，比如：<br>引用计数(Reference Counting)<br>标记清除(Mark Sweep)<br>标记整理(Maek Compact)<br>复制集合(Copy Collection)<a href="./JVM.md">详见JVM原理！</a></p>
<p>注意：<br>GC只负责堆内存的垃圾回收<br>引用类型都是存在堆中的，所以他的分配和释放都通过垃圾回收机制来管理</p>
<p>栈(Stack)上的内存是由系统自动管理的<br>值类型在栈中分配内存的，让门有自己的声明周期，不用对他们进行管理，会自动的分配和释放</p>
<p>c#中内存回收机制的大概原理<br>0代内存     1代内存     2代内存<br>代是垃圾回收机制使用的一种算法(分代算法)<br>新分配的内存在0代内存中，每次分配都进行垃圾回收以释放内存（0代满时）</p>
<p>在一次内存回收过程开始时，垃圾回收器会认为堆中全是垃圾会进行一下两步</p>
<ol>
<li>标记对象 从root开始，标记后为可达对象</li>
<li>搬迁对象压缩栈（挂起执行托管线程）释放未标记对象，搬迁可达对象，修改引用地址<br>大对象被认为是2代内存，不会对大内存进行搬迁压缩<br>（jvm垃圾回收，新生代，老生代，非常相似）</li>
</ol>
<hr>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>包裹类<br><code>using</code>引用命名空间<br>命名空间可以包裹命名空间</p>
<hr>
<h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><p>c#提供的处理字符串的公共类<br><code>.Capacity()</code><br><code>.Length()</code><br><code>.Append()</code><br><code>.Insert()</code><br><code>.Remove()</code><br><code>.Replace()</code><br><code>.Clear()</code><br>感觉是stringbuffer c#版</p>
<hr>
<h1 id="简单数据结构类"><a href="#简单数据结构类" class="headerlink" title="简单数据结构类"></a>简单数据结构类</h1><h2 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h2><h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><hr>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">test</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span>:<span class="title">strcut</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="keyword">value</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p><code>where</code>struct/class/new()/interface</p>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h2 id="Dictionary"><a href="#Dictionary" class="headerlink" title="Dictionary"></a>Dictionary</h2><h2 id="Linekerlist"><a href="#Linekerlist" class="headerlink" title="Linekerlist"></a>Linekerlist</h2><hr>
<h1 id="委托和事件"><a href="#委托和事件" class="headerlink" title="委托和事件"></a>委托和事件</h1><h2 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h2><p>关键字<code>delegate</code><br>装载函数的容器<br>常用在：</p>
<ol>
<li>作为类的成员</li>
<li>作为函数的参数</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyFun</span>()</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    MyFun f = <span class="keyword">new</span> Myfun(Fun);</span><br><span class="line">    MyFun f2 = Fun;<span class="comment">//和上面其实是一样的</span></span><br><span class="line">    f.Invoke();</span><br><span class="line">    f2();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span>()</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> MyFun fun;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testfun</span>(<span class="params">MyFun fun</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//先处理一些别的逻辑 处理完了再执行别的函数</span></span><br><span class="line">        <span class="comment">//延迟执行！</span></span><br><span class="line">        fun();</span><br><span class="line">        <span class="keyword">this</span>.fun = fun;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如何用委托存储多个函数</span></span><br><span class="line">Myfun ff = Fun;</span><br><span class="line">ff += Fun;</span><br><span class="line"><span class="comment">//多减不会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="系统定义好的委托"><a href="#系统定义好的委托" class="headerlink" title="系统定义好的委托"></a>系统定义好的委托</h3><p>需要引用using System;<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first type 无参无返回值</span></span><br><span class="line">Action action = Fun;</span><br><span class="line">action +=Fun;</span><br><span class="line"><span class="comment">//就不用自己写啦——</span></span><br><span class="line"><span class="comment">//second type 可以指定返回类型的</span></span><br><span class="line">Func&lt;<span class="built_in">string</span>&gt; funcString =fun2;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">fun2</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//third type 可以传n个参数的</span></span><br><span class="line">Action&lt;<span class="built_in">int</span>,<span class="built_in">string</span>&gt; action2 = fun6;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>委托怎么用，事件就怎么用<br><code>event</code><br>事件是作为成员变量存在于类中<br>区别：</p>
<ol>
<li>事件不能在类外部赋值</li>
<li>不能在类外部调用</li>
</ol>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">event</span> Action myEvent;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFun</span>()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">myEvent = testFun;</span><br><span class="line">myEvent += testFun;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Action a = <span class="built_in">delegate</span>()&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>lambad可以理解为简写</p>
<hr>
<h1 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h1><p>协变：out<br>逆变：in<br>卧槽看晕了</p>
<hr>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>Thread t = new Thread();<br>run逻辑不用实现接口<br>t.IsBackground = true;</p>
<hr>
<h1 id="预处理器指令"><a href="#预处理器指令" class="headerlink" title="预处理器指令"></a>预处理器指令</h1><p><code>#define</code><br><code>#undef</code></p>
<p><code>#if</code> <code>#endif</code><br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> Unity4 //如果有unity这个符号，下面的代码就会被编译</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;版本为untity4&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><br><code>warning</code> <code>error</code></p>
<hr>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><p><strong>程序集</strong>:代码集合 <code>dll</code> <code>exe</code><br><strong>元数据</strong>:程序中的类、类中的函数、变量等等<br><strong>反射</strong>:程序正在运行时查看自身的元数据或者其他程序的元数据的行为<br>人话：通过反射得到各种变量，执行、操作他们</p>
<h2 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h2><p><strong>类的信息</strong>（反射功能的基础）<br>访问元数据的主要方式<br>使用Type的成员获取有关类型声明的信息、有关类型的成员</p>
<h3 id="获取type"><a href="#获取type" class="headerlink" title="获取type"></a>获取type</h3><ol>
<li>object中的GetType()</li>
<li>typeof关键字 传入类名</li>
<li>通过类的名字<br>（类名必须包含命名空间，不然找不到<h3 id="得到类的程序集信息"><a href="#得到类的程序集信息" class="headerlink" title="得到类的程序集信息"></a>得到类的程序集信息</h3>.Assembly<h3 id="获取类中的所有公共成员"><a href="#获取类中的所有公共成员" class="headerlink" title="获取类中的所有公共成员"></a>获取类中的所有公共成员</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先得到type</span></span><br><span class="line">Type t=typeod(Test);</span><br><span class="line"><span class="comment">//然后得到所有公共成员</span></span><br><span class="line"><span class="comment">//需要using.System.Reflection;</span></span><br><span class="line">Memberinfo[] infos = t.GerMembers();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;infos.length;i++)&#123;</span><br><span class="line">    console.writeline(infos[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取类的公共构造函数并调用"><a href="#获取类的公共构造函数并调用" class="headerlink" title="获取类的公共构造函数并调用"></a>获取类的公共构造函数并调用</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConstructorInfo[] ctors = t.GetConstructors();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;ctor.Length;i++)&#123;</span><br><span class="line">    Console.WriteLine(ctors[i]);</span><br><span class="line">&#125;</span><br><span class="line">ConstructorInfo info =t.GetConstructors(<span class="keyword">new</span> Type[<span class="number">0</span>]);<span class="comment">//无参构造</span></span><br><span class="line">Test obj = info.Invoke(<span class="literal">null</span>) <span class="keyword">as</span> Test;<span class="comment">//默认传出来是objection</span></span><br><span class="line">ConstructorInfo info =t.GetConstructors(<span class="keyword">new</span> Type[]&#123;<span class="keyword">typeof</span>(<span class="built_in">int</span>)&#125;);<span class="comment">//有参构造</span></span><br><span class="line">Test obj = info.Invoke(<span class="keyword">new</span> <span class="built_in">object</span>[]&#123;<span class="number">2</span>&#125;) <span class="keyword">as</span> Test;</span><br></pre></td></tr></table></figure>
<h3 id="获取类的公共成员变量"><a href="#获取类的公共成员变量" class="headerlink" title="获取类的公共成员变量"></a>获取类的公共成员变量</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FireldInfo[] fieldInfos = t.GetFields();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;fieldInfos.Length;i++)&#123;</span><br><span class="line">    Console.WriteLIne(fieldInfos[i]);</span><br><span class="line">&#125;</span><br><span class="line">FireldInfo infoJ= t.GetFields(<span class="string">&quot;j&quot;</span>);</span><br><span class="line"><span class="comment">//通过反射获取和设置某个对象的值</span></span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line">test.j = <span class="number">99</span>;</span><br><span class="line">infoJ.GetValue(test);</span><br><span class="line">infoJ.SetValue(test,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h3 id="获得类的公共成员方法"><a href="#获得类的公共成员方法" class="headerlink" title="获得类的公共成员方法"></a>获得类的公共成员方法</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MethodInfo[] methods = t.GetMethods();</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;methods.Length;i++)&#123;</span><br><span class="line">    Console.WriteLine(methods[i]);</span><br><span class="line">&#125;</span><br><span class="line">MethodInfo method= t.GetMethods(<span class="string">&quot;substring&quot;</span>,</span><br><span class="line">    <span class="keyword">new</span> Type[]&#123;<span class="keyword">typeof</span>(<span class="built_in">int</span>),<span class="keyword">typeof</span>(<span class="built_in">int</span>)&#125;);</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;sb&quot;</span>;</span><br><span class="line"><span class="built_in">object</span> result = method.Invoke(str,<span class="keyword">new</span> <span class="built_in">object</span>[]&#123;<span class="number">7</span>,<span class="number">5</span>&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Activator"><a href="#Activator" class="headerlink" title="Activator"></a>Activator</h2>快速实例化对象的类<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Type testType = <span class="keyword">typeof</span>(Test);</span><br><span class="line">Test testObj = Activator.CreateInstance(testType) <span class="keyword">as</span> Test;<span class="comment">//无参</span></span><br><span class="line"></span><br><span class="line">Test testObj = Activator.CreateInstance(testType,<span class="number">99</span>) <span class="keyword">as</span> Test;<span class="comment">//有参</span></span><br></pre></td></tr></table></figure>
<h2 id="Assembly"><a href="#Assembly" class="headerlink" title="Assembly"></a>Assembly</h2>程序集类<code>dll</code><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Assembly asembly = Assembly.LoadFrom(<span class="string">@&quot;url&quot;</span>);</span><br><span class="line">Type icon =asembly.GetType(<span class="string">&quot;xxxx.Icon&quot;</span>);<span class="comment">//xxxx文件中的Icon类</span></span><br><span class="line"><span class="comment">//实例化一个icon对象</span></span><br><span class="line"><span class="built_in">object</span> iconobj = Activator.CreateInstance(icon,<span class="number">10</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="类库工程"><a href="#类库工程" class="headerlink" title="类库工程"></a>类库工程</h2>什么内裤攻城</li>
</ol>
<hr>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><code>[特性]</code></p>
<hr>
<p>#</p>
<h1 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h1><p>一天速成！。。。其实反射后面还没学但是我学不动了先歇了<br>一天写800行笔记我也是神人了<br>和java还是有一些微妙的差别的<br>其实感觉c#里重复的东西有点多 比如静态类的存在感觉完全没有必要 abstract也能做到<br>但是interface和abstract的区别到是比java大 c#里的接口就是纯粹的接口 java里还是能写点东西的<br>不过我java还有一些东西还没学完….这个速成的倒是很快</p>
<link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script>
    </article>
    <!-- license -->
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
                <div class="nextSlogan">Next Post</div>
                <a href="/posts/56743.html" title="unity">
                    <div class="nextTitle">unity</div>
                </a>
        </li>
        <li class="previous">
                <div class="prevSlogan">Previous Post</div>
                <a href="/posts/3629.html" title="编程细节记录">
                    <div class="prevTitle">编程细节记录</div>
                </a>
        </li>
    </ul>
    <!-- comment -->
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->

            
            
            
            <!-- utteranc评论 -->

            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->

            
            
            
        </div>
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    <!-- Mathjax -->
</main>

                <!-- profile -->
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
        <div class="social">
                            <a href="mailto:limiese0zen@gmail.com" class="iconfont-archer email" title="email" ></a>
                <a href="//github.com/zennnj" class="iconfont-archer github" target="_blank" title="github"></a>
                <a href="https://steamcommunity.com/profiles/76561199557415174" class="iconfont-archer steam" target="_blank" title="steam"></a>

        </div>
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    <!-- 不蒜子  -->
        <div class="busuanzi-container">
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
        </div>
</footer>

        </div>
        <!-- toc -->
            <div class="toc-wrapper toc-wrapper-loding" style=    top:50vh;
>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8F%B0%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.</span> <span class="toc-text">控制台输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-number">2.</span> <span class="toc-text">常量和变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%BC%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">值和引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.2.</span> <span class="toc-text">值类型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-number">3.</span> <span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7"><span class="toc-number">4.1.</span> <span class="toc-text">括号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Parse"><span class="toc-number">4.2.</span> <span class="toc-text">Parse</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Convert"><span class="toc-number">4.3.</span> <span class="toc-text">Convert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%ACString"><span class="toc-number">4.4.</span> <span class="toc-text">转String</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E6%8D%95%E8%8E%B7"><span class="toc-number">5.</span> <span class="toc-text">异常捕获</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">6.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">7.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">7.1.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E6%95%B0%E7%BB%84"><span class="toc-number">7.2.</span> <span class="toc-text">交错数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ref%E5%92%8Cout"><span class="toc-number">8.1.</span> <span class="toc-text">ref和out</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text">变长参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">8.3.</span> <span class="toc-text">参数默认值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">8.4.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">9.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">9.1.</span> <span class="toc-text">访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">结构体的构造函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E5%B0%81%E8%A3%85"><span class="toc-number">10.</span> <span class="toc-text">类-封装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">10.1.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">析构函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">10.4.</span> <span class="toc-text">成员属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">10.4.1.</span> <span class="toc-text">自动属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">索引器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-number">10.6.</span> <span class="toc-text">静态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="toc-number">10.6.1.</span> <span class="toc-text">静态成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB"><span class="toc-number">10.6.2.</span> <span class="toc-text">静态类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">10.6.3.</span> <span class="toc-text">静态构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">10.7.</span> <span class="toc-text">拓展方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">10.8.</span> <span class="toc-text">运算符重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.9.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%83%A8%E7%B1%BB"><span class="toc-number">10.10.</span> <span class="toc-text">分部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.11.</span> <span class="toc-text">分部方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E7%BB%A7%E6%89%BF"><span class="toc-number">11.</span> <span class="toc-text">类-继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">11.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99"><span class="toc-number">11.2.</span> <span class="toc-text">里氏替换原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#is-amp-as"><span class="toc-number">11.2.1.</span> <span class="toc-text">is&amp;as</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">11.3.</span> <span class="toc-text">继承中的构造器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%87%E7%89%A9%E4%B9%8B%E7%88%B6"><span class="toc-number">11.4.</span> <span class="toc-text">万物之父</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1"><span class="toc-number">11.4.1.</span> <span class="toc-text">拆箱装箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E7%B1%BB"><span class="toc-number">11.5.</span> <span class="toc-text">密封类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB-%E5%A4%9A%E6%80%81"><span class="toc-number">12.</span> <span class="toc-text">类-多态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vob"><span class="toc-number">12.1.</span> <span class="toc-text">vob</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.3.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%86%E5%B0%81%E6%96%B9%E6%B3%95"><span class="toc-number">12.4.</span> <span class="toc-text">密封方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">结构体和类的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text">抽象类和接口的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">16.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#StringBuilder"><span class="toc-number">17.</span> <span class="toc-text">StringBuilder</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB"><span class="toc-number">18.</span> <span class="toc-text">简单数据结构类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Arraylist"><span class="toc-number">18.1.</span> <span class="toc-text">Arraylist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">18.2.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue"><span class="toc-number">18.3.</span> <span class="toc-text">Queue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable"><span class="toc-number">18.4.</span> <span class="toc-text">Hashtable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">19.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="toc-number">19.1.</span> <span class="toc-text">泛型约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">19.2.</span> <span class="toc-text">List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dictionary"><span class="toc-number">19.3.</span> <span class="toc-text">Dictionary</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linekerlist"><span class="toc-number">19.4.</span> <span class="toc-text">Linekerlist</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">20.</span> <span class="toc-text">委托和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98"><span class="toc-number">20.1.</span> <span class="toc-text">委托</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E5%A5%BD%E7%9A%84%E5%A7%94%E6%89%98"><span class="toc-number">20.1.1.</span> <span class="toc-text">系统定义好的委托</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">20.2.</span> <span class="toc-text">事件</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-number">21.</span> <span class="toc-text">匿名函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E5%8F%98%E5%92%8C%E9%80%86%E5%8F%98"><span class="toc-number">22.</span> <span class="toc-text">协变和逆变</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">23.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">24.</span> <span class="toc-text">预处理器指令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">25.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Type"><span class="toc-number">25.1.</span> <span class="toc-text">Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96type"><span class="toc-number">25.1.1.</span> <span class="toc-text">获取type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%97%E5%88%B0%E7%B1%BB%E7%9A%84%E7%A8%8B%E5%BA%8F%E9%9B%86%E4%BF%A1%E6%81%AF"><span class="toc-number">25.1.2.</span> <span class="toc-text">得到类的程序集信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98"><span class="toc-number">25.1.3.</span> <span class="toc-text">获取类中的所有公共成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%B9%B6%E8%B0%83%E7%94%A8"><span class="toc-number">25.1.4.</span> <span class="toc-text">获取类的公共构造函数并调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">25.1.5.</span> <span class="toc-text">获取类的公共成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%BE%97%E7%B1%BB%E7%9A%84%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-number">25.1.6.</span> <span class="toc-text">获得类的公共成员方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activator"><span class="toc-number">25.2.</span> <span class="toc-text">Activator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Assembly"><span class="toc-number">25.3.</span> <span class="toc-text">Assembly</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%BA%93%E5%B7%A5%E7%A8%8B"><span class="toc-number">25.4.</span> <span class="toc-text">类库工程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">26.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8E%E8%AF%9D"><span class="toc-number">27.</span> <span class="toc-text">后话</span></a></li></ol>
            </div>
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    <div class="total-and-search">
        <div class="total-archive">
        Total : 21
        </div>
        <!-- search  -->
    </div>
    <div class="post-archive">
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">03/08</span>
            <a class="archive-post-title" href="/posts/5751eea2.html">C++</a>
        </li>
                </ul>
            <div class="archive-year"> 2024 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span>
            <a class="archive-post-title" href="/posts/79666db.html">数据结构</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/12</span>
            <a class="archive-post-title" href="/posts/8c0da805.html">「置顶」</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/posts/33757.html">SSM</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/posts/74add858.html">Git使用指南</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span>
            <a class="archive-post-title" href="/posts/12634.html">本站使用的插件</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span>
            <a class="archive-post-title" href="/posts/50460.html">做题记录串</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span>
            <a class="archive-post-title" href="/posts/56743.html">unity</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span>
            <a class="archive-post-title" href="/posts/59760.html">C#</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/19</span>
            <a class="archive-post-title" href="/posts/3629.html">编程细节记录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span>
            <a class="archive-post-title" href="/posts/58846.html">Java多线程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span>
            <a class="archive-post-title" href="/posts/17374.html">JVM</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span>
            <a class="archive-post-title" href="/posts/9977.html">MySQL</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/40121.html">JAVA</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/41682.html">设计模式</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/7165.html">Github访问连接失败问题</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/28758.html">计算机网络</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span>
            <a class="archive-post-title" href="/posts/15691.html">Linux</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span>
            <a class="archive-post-title" href="/posts/31602.html">后端</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">08/31</span>
            <a class="archive-post-title" href="/posts/12966.html">上学前的遗言</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span>
            <a class="archive-post-title" href="/posts/37559.html">个人用使用指南</a>
        </li>
            </ul>
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
            <span class="sidebar-tag-name" data-tags="learn">
                <span class="iconfont-archer">&#xe606;</span>
                learn
            </span>
            <span class="sidebar-tag-name" data-tags="problems">
                <span class="iconfont-archer">&#xe606;</span>
                problems
            </span>
            <span class="sidebar-tag-name" data-tags="practice">
                <span class="iconfont-archer">&#xe606;</span>
                practice
            </span>
            <span class="sidebar-tag-name" data-tags="碎碎念">
                <span class="iconfont-archer">&#xe606;</span>
                碎碎念
            </span>
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
        <span class="sidebar-category-name" data-categories="JAVA">
            <span class="iconfont-archer">&#xe60a;</span>
            JAVA
        </span>
        <span class="sidebar-category-name" data-categories="记录">
            <span class="iconfont-archer">&#xe60a;</span>
            记录
        </span>
        <span class="sidebar-category-name" data-categories="数据库">
            <span class="iconfont-archer">&#xe60a;</span>
            数据库
        </span>
        <span class="sidebar-category-name" data-categories="unity">
            <span class="iconfont-archer">&#xe60a;</span>
            unity
        </span>
        <span class="sidebar-category-name" data-categories="框架">
            <span class="iconfont-archer">&#xe60a;</span>
            框架
        </span>
        <span class="sidebar-category-name" data-categories="计算机">
            <span class="iconfont-archer">&#xe60a;</span>
            计算机
        </span>
        <span class="sidebar-category-name" data-categories="secrets">
            <span class="iconfont-archer">&#xe60a;</span>
            secrets
        </span>
        <span class="sidebar-category-name" data-categories="use">
            <span class="iconfont-archer">&#xe60a;</span>
            use
        </span>
        <span class="sidebar-category-name" data-categories="chat">
            <span class="iconfont-archer">&#xe60a;</span>
            chat
        </span>
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "http://example.com",
        root: siteMetaRoot,
        author: ""
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->

        <!-- main func -->
        <script src="/scripts/main.js"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" onload="window.Fancybox.bind('[data-fancybox]')" defer></script>
        <!-- algolia -->
        <!-- busuanzi -->
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        <!-- async load share.js -->
            <script src="/scripts/share.js" async></script>
        <!-- mermaid -->
    <!-- hexo injector body_end start --><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/js/index.js"></script><!-- hexo injector body_end end --></body>
</html>
