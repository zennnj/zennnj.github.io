<!DOCTYPE html>
<html lang="zh-CN">
    <!-- title -->
<!-- keywords -->
<head><!-- hexo injector head_begin start --><link href="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/css/index.css" rel="stylesheet"/><!-- hexo injector head_begin end -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="author" content="">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="">
        <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    <meta name="description" content="">
    <meta name="description" content="太好了是期末周我们没救了">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/posts/79666db.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="太好了是期末周我们没救了">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-1.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-2.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-3.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-4.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-5.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-6.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-7.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-8.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-9.png">
<meta property="og:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-10.png">
<meta property="article:published_time" content="2024-12-12T11:12:06.000Z">
<meta property="article:modified_time" content="2025-04-19T11:40:28.266Z">
<meta property="article:tag" content="learn">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <link rel="icon" href="/assets/my.ico">
    <title>数据结构 · Terminal 4</title>
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
    (function (w) {
        'use strict'
        // rel=preload support test
        if (!w.loadCSS) {
            w.loadCSS = function () {}
        }
        // define on the loadCSS obj
        var rp = (loadCSS.relpreload = {})
        // rel=preload feature support test
        // runs once and returns a function for compat purposes
        rp.support = (function () {
            var ret
            try {
                ret = w.document.createElement('link').relList.supports('preload')
            } catch (e) {
                ret = false
            }
            return function () {
                return ret
            }
        })()

        // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
        // then change that media back to its intended value on load
        rp.bindMediaToggle = function (link) {
            // remember existing media attr for ultimate state, or default to 'all'
            var finalMedia = link.media || 'all'

            function enableStylesheet() {
                link.media = finalMedia
            }

            // bind load handlers to enable media
            if (link.addEventListener) {
                link.addEventListener('load', enableStylesheet)
            } else if (link.attachEvent) {
                link.attachEvent('onload', enableStylesheet)
            }

            // Set rel and non-applicable media type to start an async request
            // note: timeout allows this to happen async to let rendering continue in IE
            setTimeout(function () {
                link.rel = 'stylesheet'
                link.media = 'only x'
            })
            // also enable media after 3 seconds,
            // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
            setTimeout(enableStylesheet, 3000)
        }

        // loop through link elements in DOM
        rp.poly = function () {
            // double check this to prevent external calls from running
            if (rp.support()) {
                return
            }
            var links = w.document.getElementsByTagName('link')
            for (var i = 0; i < links.length; i++) {
                var link = links[i]
                // qualify links to those with rel=preload and as=style attrs
                if (
                    link.rel === 'preload' &&
                    link.getAttribute('as') === 'style' &&
                    !link.getAttribute('data-loadcss')
                ) {
                    // prevent rerunning on link
                    link.setAttribute('data-loadcss', true)
                    // bind listeners to toggle media back
                    rp.bindMediaToggle(link)
                }
            }
        }

        // if unsupported, run the polyfill
        if (!rp.support()) {
            // run once at least
            rp.poly()

            // rerun poly on an interval until onload
            var run = w.setInterval(rp.poly, 500)
            if (w.addEventListener) {
                w.addEventListener('load', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            } else if (w.attachEvent) {
                w.attachEvent('onload', function () {
                    rp.poly()
                    w.clearInterval(run)
                })
            }
        }

        // commonjs
        if (typeof exports !== 'undefined') {
            exports.loadCSS = loadCSS
        } else {
            w.loadCSS = loadCSS
        }
    })(typeof global !== 'undefined' ? global : this)
</script>

    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .footer-fixed-btn,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(
            -45deg,
            #444 0,
            #444 80px,
            #333 80px,
            #333 160px
        );
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }
</style>

    <link id="stylesheet-fancybox" rel="preload" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-base" rel="preload" href="/css/style.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link id="stylesheet-mobile" rel="preload" href="/css/mobile.css" as="style" onload="this.onload=null;this.rel='stylesheet';this.media='screen and (max-width: 960px)'">
    <link id="stylesheet-theme-dark" rel="preload" href="/css/dark.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" as="script">
    <link rel="preload" href="/scripts/main.js" as="script">
    <link rel="preload" href="/font/Oswald-Regular.ttf" as="font" crossorigin>
    <link rel="preload" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" as="font" crossorigin>
    <!-- algolia -->
    <!-- 百度统计  -->
    <!-- 谷歌统计  -->
    <!-- Google tag (gtag.js) -->
<style type="text/css">
.spoiler {
  display: inline;
}
p.spoiler {
  display: flex;
}
.spoiler a {
  pointer-events: none;
}
.spoiler-blur, .spoiler-blur > * {
  transition: text-shadow .5s ease;
}
.spoiler .spoiler-blur, .spoiler .spoiler-blur > * {
  color: rgba(0, 0, 0, 0);
  background-color: rgba(0, 0, 0, 0);
  text-shadow: 0 0 10px grey;
  cursor: pointer;
}
.spoiler .spoiler-blur:hover, .spoiler .spoiler-blur:hover > * {
  text-shadow: 0 0 5px grey;
}
.spoiler-box, .spoiler-box > * {
  transition: color .5s ease,
  background-color .5s ease;
}
.spoiler .spoiler-box, .spoiler .spoiler-box > * {
  color: black;
  background-color: black;
  text-shadow: none;
}</style><meta name="generator" content="Hexo 7.3.0"></head>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ == undefined) {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js" />')
        }
    </script>
        <body class="post-body">
        <!-- header -->
        <header class="header header-mobile">
    <!-- top read progress line -->
    <div class="header-element">
        <div class="read-progress"></div>
    </div>
    <!-- sidebar menu button -->
    <div class="header-element">
        <div class="header-sidebar-menu">
            <div style="padding-left: 1px;">&#xe775;</div>
        </div>
    </div>
    <!-- header actions -->
    <div class="header-actions">
        <!-- theme mode switch button -->
        <span class="header-theme-btn header-element">
            <i class="fas fa-adjust"></i>
        </span>
        <!-- back to home page text -->
        <span class="home-link header-element">
            <a href="/">Terminal 4.</a>
        </span>
    </div>
    <!-- toggle banner -->
    <div class="banner">
        <div class="blog-title header-element">
            <a href="/">Terminal 4.</a>
        </div>
        <div class="post-title header-element">
            <a href="#" class="post-name">数据结构</a>
        </div>
    </div>
</header>

        <!-- fixed footer -->
        <footer class="footer-fixed">
    <!-- donate button -->
    <div class="donate-popup donate-popup--hidden">
    <div class="donate-popup__title">Buy Me A Milktea!</div>
    <div class="donate-popup__content">
        <div class="donate-popup__content-description">If this post helped you, please consider buying the author a cup of milktea 🥤!(Actually,I prefer fruit tea.🥳)</div>
        <img
            class="donate-popup__content-qrCode"
            title="Wechat"
            alt="Wechat"
            src="/assets/donate-wechat.png"
        ></img>
        <img
            class="donate-popup__content-qrCode"
            title="Alipay"
            alt="Alipay"
            src="/assets/donate-alipay.jpg"
        ></img>
    </div>
</div>

    <div
        title="Donate to the author"
        class="footer-fixed-btn footer-fixed-btn--hidden donate-btn"
    >
        <i class="fas fa-donate"></i>
    </div>

    <!-- back to top button -->
    <div class="footer-fixed-btn footer-fixed-btn--hidden back-top">
        <div>&#xe639;</div>
    </div>
</footer>

        <!-- wrapper -->
        <div class="wrapper">
            <div class="site-intro" style="    height:50vh;
">
    <!-- 主页  -->
    <!-- 404页  -->
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
                数据结构
            <!-- 404 -->
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            <!-- 404 -->
        </p>
        <!-- 文章页 meta -->
            <div class="post-intros">
                <!-- 文章页标签  -->
                    <div class="post-intro-tags" >
        <a class="post-tag" href="javascript:void(0);" data-tags="learn">learn</a>
</div>

                <!-- 文章字数统计 -->
                <div class="post-intro-meta">
                    <!-- 撰写日期 -->
                    <span class="iconfont-archer post-intro-calander">&#xe676;</span>
                    <span class="post-intro-time">2024/12/12</span>
                    <!-- busuanzi -->
                        <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                            <span class="iconfont-archer post-intro-busuanzi">&#xe602;</span>
                            <span id="busuanzi_value_page_pv"></span>
                        </span>
                    <!-- 文章分享 -->
                    <span class="share-wrapper">
                        <span class="iconfont-archer share-icon">&#xe71d;</span>
                        <span class="share-text">Share</span>
                        <ul class="share-list">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
    </div>
</div>

            <script>
  // get user agent
  function getBrowserVersions() {
    var u = window.navigator.userAgent
    return {
      userAgent: u,
      trident: u.indexOf('Trident') > -1, //IE内核
      presto: u.indexOf('Presto') > -1, //opera内核
      webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
      gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
      mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
      ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
      android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
      iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
      iPad: u.indexOf('iPad') > -1, //是否为iPad
      webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
      weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
      uc: u.indexOf('UCBrowser') > -1, //是否为android下的UC浏览器
    }
  }
  var browser = {
    versions: getBrowserVersions(),
  }
  console.log('userAgent: ' + browser.versions.userAgent)

  // callback
  function fontLoaded() {
    console.log('font loaded')
    if (document.getElementsByClassName('site-intro-meta')) {
      document
        .getElementsByClassName('intro-title')[0]
        .classList.add('intro-fade-in')
      document
        .getElementsByClassName('intro-subtitle')[0]
        .classList.add('intro-fade-in')
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in')
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb() {
    if (browser.versions.uc) {
      console.log('UCBrowser')
      fontLoaded()
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular'],
        },
        loading: function () {
          // 所有字体开始加载
          // console.log('font loading');
        },
        active: function () {
          // 所有字体已渲染
          fontLoaded()
        },
        inactive: function () {
          // 字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout')
          fontLoaded()
        },
        timeout: 5000, // Set the timeout to two seconds
      })
    }
  }

  function asyncErr() {
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0]
    o.src = u
    if (cb) {
      o.addEventListener(
        'load',
        function (e) {
          cb(null, e)
        },
        false
      )
    }
    if (err) {
      o.addEventListener(
        'error',
        function (e) {
          err(null, e)
        },
        false
      )
    }
    s.parentNode.insertBefore(o, s)
  }

  var asyncLoadWithFallBack = function (arr, success, reject) {
    var currReject = function () {
      reject()
      arr.shift()
      if (arr.length) async(arr[0], success, currReject)
    }

    async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack(
    [
      'https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js',
      'https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js',
      "/lib/webfontloader.min.js",
    ],
    asyncCb,
    asyncErr
  )
</script>

            <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" alt="loading">
            <div class="container container-unloaded">
                <main class="main post-page">
    <article class="article-entry">
        <link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>太好了是期末周我们没救了<br><span id="more"></span></p>
<h1 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h1><p><img src="../images/数据结构/image.png" alt="alt text"></p>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">LNode</span>&#123;</span> </span><br><span class="line">    ElementType  *Data;  </span><br><span class="line">    <span class="type">int</span> MaxSize; </span><br><span class="line">    Position  Last;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span> </span><br><span class="line">       ElementType  Data;   </span><br><span class="line">       PtrToLNode Next;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>带头结点查找指定序号时大多cnt=0，一般从1开始编号，不过还是按实际情况判断吧！&gt;&lt;</p>
</blockquote>
<p>定义三元组(a, b, c)（其中a, b, c均为正数）的距离D=|a-b| + |b-c| + |c-a|。给定三个非空整数集合S1、S2和S3，按升序分别存储在3个数组中。设计一个尽可能高效的算法，计算并输出所有可能的三元组(a, b, c)（a∈S1, b∈S2, c∈S3）中的最小距离。<br>要求：<br>（1）给出算法的基本设计思想。<br>（2）根据设计思想，采用 C 语言描述算法，关键之处给出注释。<br>（3）说明你所设计算法的时间复杂度和空间复杂度。<br>【算法基本设计思想】<br>1）使用Dmin记录所有已处理的三元组的最小距离<br>2）S1、S2、S3分别保存在数组A、B、C中。数组的下标变量i=j=k=0，当i&lt;|S1|&amp;&amp;j&lt;|S2|&amp;&amp;k&lt;|S3|时，执行下面的循环操作：</p>
<ul>
<li>计算(A[i]、B[j]、C[k])的距离D；</li>
<li>若D&lt;Dmin，则Dmin=D；</li>
<li>将A[i]、B[j]、C[k]中的最小值的下标+1（对照分析，最小值为a，最大值为c时，c 不变而更新a，寻找更小的距离）<br>3）输出Dmin，结束。</li>
</ul>
<p>链式存储结构比顺序存储结构能更方便地表示各种逻辑结构（顺序存储只能用物理上的邻接关系来表示逻辑结构）</p>
<h3 id="广义表与多重链表"><a href="#广义表与多重链表" class="headerlink" title="广义表与多重链表"></a>广义表与多重链表</h3><p>广义表中元素可以是另一个广义表<br>一个链表，其元素可能还是另一个子链表的起点指针，叫“多重链表”</p>
<p><img src="../images/数据结构/image-1.png" alt="alt text"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>“ 堆栈（Stack）”可以认为是具有一定操作约束的线性表，插入和删除操作都作用在一个称为栈顶(Top)的端点位置。<br>1、Stack CreateStack( int MaxSize )： 生成空堆栈，其最大长度为MaxSize；<br>2、bool IsFull( Stack S )：判断堆栈S是否已满。若S中元素个数等于MaxSize时返回true；否则返回false ；<br><strong>3、bool Push( Stack S, ElementType X )：将元素X压入堆栈。若堆栈已满，返回false；否则将数据元素X插入到堆栈S栈顶处并返回true；</strong><br>4、bool IsEmpty ( Stack S )：判断堆栈S是否为空，若是返回true；否则返回false；<br><strong>5、ElementType Pop( Stack S )：删除并返回栈顶元素。若堆栈为空，返回错误信息；否则将栈顶数据元素从堆栈中删除并返回。</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">PtrToSNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">SNode</span> &#123;</span></span><br><span class="line">    ElementType  *Data; <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    Position  Top;              <span class="comment">/* 栈顶指针 */</span></span><br><span class="line">    <span class="type">int</span>  MaxSize;               <span class="comment">/* 堆栈最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>  PtrToSNode  Stack;</span><br></pre></td></tr></table></figure><br>顺便一提，我常写的版本是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">SNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *Data; <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="type">int</span> stacksize;              <span class="comment">/* 栈储存数 其实没区别！*/</span></span><br><span class="line">    <span class="type">int</span> capacity;               <span class="comment">/* 堆栈最大容量 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><strong>共享栈</strong>:在数组头和尾设栈，top相遇则满</p>
<h3 id="堆栈的链式存储实现"><a href="#堆栈的链式存储实现" class="headerlink" title="堆栈的链式存储实现"></a>堆栈的链式存储实现</h3><p>栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行；栈顶指针Top就是链表的头指针。</p>
<h3 id="堆栈应用：表达式求值"><a href="#堆栈应用：表达式求值" class="headerlink" title="堆栈应用：表达式求值"></a>堆栈应用：表达式求值</h3><p><strong>中缀表达式转换为后缀表达式</strong></p>
<ol>
<li>如果遇到空格则认为是分隔符，不需处理；</li>
<li>若遇到运算数，则直接输出；</li>
<li>若是左括号，则将其压入堆栈中；</li>
<li>若遇到的是右括号，表明括号内的中缀表达式已经扫描完毕，将栈顶的运算符弹出并输出，直到遇到左括号（左括号也出栈，但不输出）；</li>
<li>若遇到的是运算符，若该运算符的优先级大于栈顶运算符的优先级时，则把它压栈；若该运算符的优先级小于<strong>等于</strong>栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，按同样处理方法，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；</li>
<li>若中缀表达式中的各对象处理完毕，则把堆栈中存留的运算符一并输出。</li>
</ol>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>“队列(Queue)” 是具有一定操作约束的线性表，插入和删除操作有一定要求：只能在一端插入，而在另一端删除。<br>1、Queue CreatQueue(int MaxSize )：生成长度为MaxSize的空队列；</p>
<p>2、bool IsFullQ(Queue Q)：判断队列Q是否已满，若是返回true；否则返回false；<br>(Q-&gt;Rear+1)%Q-&gt;MaxSize = = Q-&gt;Front;</p>
<p><strong>3、 bool AddQ(Queue Q, ElementType X )： 将元素X压入队列Q。若队列已经满了，返回false；否则将数据元素X插入到队列Q并返回true；</strong><br>Q-&gt;Rear = (Q-&gt;Rear+1)%Q-&gt;MaxSize;</p>
<p>4、 bool IsEmptyQ(Queue Q )：判断队列Q是否为空，若是返回true；否则返回false；</p>
<p><strong>5、ElementType DeleteQ(Queue Q )：删除并返回队列头元素。若队列为空，返回错误信息；否则将队头数据元素从队列中删除并返回。</strong><br>(Q-&gt;Front+1)%Q-&gt;MaxSize;</p>
<p>按照教材来说，Front不放东西，Rear放东西。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="type">int</span>  Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">PtrToQNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;	</span><br><span class="line">    Position Front, Rear;  </span><br><span class="line">    <span class="type">int</span> MaxSize;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>   PtrToQNode  Queue;</span><br></pre></td></tr></table></figure></p>
<h3 id="队列的链式存储实现"><a href="#队列的链式存储实现" class="headerlink" title="队列的链式存储实现"></a>队列的链式存储实现</h3><p>队列采用链式存储结构，队列的头必须指向链表的头结点，队列的尾指向链表的尾结点。</p>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列进队时，前端进的元素排列在队列中后端进的元素的前面，后端进的元素排列在队列中前端进的元素的后面。在双端队列出队时，无论是前端还是后端，出队先出的元素排列在后出的元素的前面。</p>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><img src="../images/数据结构/image-2.png" alt="alt text"><br>【查找的效率】静态查找用“<strong>平均查找长度</strong>”（ASL，Average Search Length）来衡量。<br><img src="../images/数据结构/image-3.png" alt="alt text"><br><strong>二分查找</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Position <span class="title function_">BinarySearch</span><span class="params">( List Tbl, ElementType K )</span></span><br><span class="line">&#123; </span><br><span class="line">    Position left, right, mid;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">1</span>;          <span class="comment">/* 初始左边界 */</span></span><br><span class="line">    right = Tbl-&gt;Last; <span class="comment">/* 初始右边界 */</span></span><br><span class="line">    <span class="keyword">while</span>( left&lt;=right )</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (left+right)/<span class="number">2</span>;  <span class="comment">/* 计算中间元素坐标 */</span></span><br><span class="line">        <span class="keyword">if</span>( K&lt;Tbl-&gt;Data[mid] )      right = mid - <span class="number">1</span>; <span class="comment">/* 调整右边界 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( K&gt;Tbl-&gt;Data[mid] ) left = mid + <span class="number">1</span>;  <span class="comment">/* 调整左边界 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;   <span class="comment">/* 查找成功，返回数据元素的下标 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;   <span class="comment">/* 返回查找不成功的标识 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>二分查找算法具有对数的时间复杂度O(logN)</p>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是n（n≥0）个结点构成的有限集合。当n=0时，称为空树；<br>对于任一棵非空树（n&gt; 0），它具备以下性质：</p>
<ol>
<li>树中有一个称为“根（Root）”的特殊结点，用 r 表示；</li>
<li>其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2，… ，Tm，其中每个集合本身又是一棵树，这些树称为原来树的“子树（SubTree）”。每个子树的根结点都与 r 有一条相连接的边，r是这些子树根结点的“父结点(Parent)”</li>
</ol>
<ul>
<li>子树是不相交的；</li>
<li>除了根结点外，每个结点有且仅有一个父结点；</li>
<li><strong>一棵N个结点的树有N-1条边。</strong>=&gt;树中的结点数等于所有结点的度数之和加1</li>
</ul>
<h2 id="重要术语"><a href="#重要术语" class="headerlink" title="重要术语"></a>重要术语</h2><p>结点的度（Degree）：一个结点的度是其子树的个数。<br>    树的度：树的所有结点中最大的度数<br>    <strong>度为m的树中第i层上至多有mi-1个结点（i&gt;=1）</strong><br>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。<br>子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。<br>结点的层次（Level）：<strong>规定根结点在1层</strong>，其它任一结点的层数是其父结点的层数加1。<br>树的高度（Height）：树中所有结点中的最大层次是这棵树的高度，<strong>自底向上计数</strong>。注意：和树的深度的区别</p>
<p>树最适合用来表示元素之间具有分支层次关系的数据</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>一棵二叉树T是一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。可见左子树和右子树还是二叉树。<br><strong>二叉树与树不同，除了每个结点至多有两棵子树外，子树有左右顺序之分。</strong><br>二叉树平均深度<img src="../images/数据结构/image-4.png" alt="alt text"></p>
<blockquote>
<p><strong>深度为k的二叉树有最大结点总数为：2^k-1,k&gt;=1.</strong><br>对任何非空的二叉树 T，若<em>n0表示叶结点的个数</em>、<em>n2是度为2的非叶结点个数</em>，那么两者满足关系<strong>n0 = n2 +1</strong><br>n=n0+n1+n2</p>
</blockquote>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>斜二叉树(Skewed Binary Tree)（也称为退化二叉树）（不想放图了，歪的<br><strong>完美二叉树(Perfect Binary Tree)</strong><br>一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1 ≤ i ≤ n）的结点与满二叉树中编号为 i 的结点在二叉树中的位置相同，则这棵二叉树称为<strong>完全二叉树(Complete Binary Tree)</strong>。<br><img src="../images/数据结构/image-5.png" alt="alt text"><br>(感觉左边这个比较好理解&gt;&lt;)</p>
<blockquote>
<p>【习题】若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数是&gt;（    ）。<br>  A. 257；<br>  B. 258；<br>  C. 384；<br>  D. 385；</p>
<p>【习题】已知一棵完全二叉树的第6层（设根为第1层）有8个叶结点，则该完全二叉树的结点个数最多是（   ）。<br>  A. 39；<br>  B. 52；<br>  C. 111；<br>  D. 119；</p>
</blockquote>
<h2 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h2><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><a href="#特殊二叉树">完全二叉树</a>最适合这种存储。</p>
<ul>
<li>非根结点（序号 i &gt; 1）的父结点的序号是 ⌊i/2⌋;</li>
<li>结点（序号为 i ）的左孩子结点的序号是 2i，2i&lt;= n，否则没有左孩子）;</li>
<li>结点（序号为 i ）的右孩子结点的序号是  2i+1，2i+1&lt;= n，否则没有右孩子）;</li>
</ul>
<p>一般二叉树采用这种结构将造成空间浪费！（中间的编号没有节点）</p>
<h3 id="链表存储"><a href="#链表存储" class="headerlink" title="链表存储"></a>链表存储</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree; <span class="comment">/* 二叉树类型 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span> <span class="comment">/* 树结点定义 */</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">    BinTree Left;     <span class="comment">/* 指向左子树 */</span></span><br><span class="line">    BinTree Right;    <span class="comment">/* 指向右子树 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>中序遍历：左-根-右<br>先序遍历：根-左-右<br>后序遍历：左-右-根</p>
<h3 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h3><p>以中序遍历为例。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraversal</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        InOrderTraversal( BT-&gt;Left );</span><br><span class="line">        <span class="built_in">printf</span>(“%d”, BT-&gt;Data);</span><br><span class="line">        InOrderTraversal( BT-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？如果正好相同，又该是什么形态呢？<br>先序是NLR，后序是LRN，现在是NLR=NRL，则L或者R为空，所以二叉树的每层只有一个结点，即二叉树的形态要求是其高度等于结点个数。<br>如果要求NLR=LRN，则LR都应该为空，即二叉树只有一个根结点</p>
<p>若一棵二叉树的前序遍历序列为a,e,b,d,c，后序遍历序列为b,c,d,e,a，则根结点的孩子结点（       ）。<br>A.只有e           B.有e、b            C.有e、c      D. 无法确定<br>由前序和后序序列可以判断a是根结点，<strong>如果e和b是兄弟结点，那么前序和后序e、b的顺序不会改变</strong>，所以b不是e的兄弟结点</p>
</blockquote>
<h4 id="创建二叉树"><a href="#创建二叉树" class="headerlink" title="创建二叉树"></a>创建二叉树</h4><p>按<strong>先序创建</strong>(ABD##E##CF###)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Create_Bintree</span><span class="params">( )</span> &#123;</span><br><span class="line">    BinTree BT; </span><br><span class="line">    <span class="type">char</span> ch; </span><br><span class="line">    <span class="keyword">if</span>((ch = getchar( )) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        BT = <span class="literal">NULL</span>;<span class="comment">//空子树 </span></span><br><span class="line">    <span class="keyword">else</span>&#123; </span><br><span class="line">        BT = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">        BT -&gt;data = ch;</span><br><span class="line">        BT -&gt;lchild=Create_Bintree( );</span><br><span class="line">        BT -&gt;rchild=Create_Bintree( );     </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> BT;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>按<strong>层序创建</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">BinTree  <span class="title function_">CreatBinTree</span><span class="params">( )</span>&#123;</span><br><span class="line">    ElementType  Data;</span><br><span class="line">    BinTree  bt,  t;</span><br><span class="line">    Queue  Q=CreatQueue( );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请以数字的形式输入结点信息：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;Data);</span><br><span class="line">    <span class="keyword">if</span>( Data==NoInfo ) </span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">           <span class="comment">//生成一个二叉树结点</span></span><br><span class="line">    bt=(BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">    bt-&gt;data=Data;</span><br><span class="line">    bt-&gt;Left=bt-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">    AddQ(Q,bt);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))  &#123;</span><br><span class="line">        t=DeleteQ(Q);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Data);</span><br><span class="line">        <span class="keyword">if</span>(Data==NoInfo) t-&gt;Left=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t-&gt;Left=(BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">            t-&gt;Left-&gt;data=Data;</span><br><span class="line">            t-&gt;Left-&gt;Left=t-&gt;Left-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">            AddQ(Q,t-&gt;Left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;Data);</span><br><span class="line">        <span class="keyword">if</span>(Data==NoInfo) t-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t-&gt;Right=(BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">            t-&gt;Right-&gt;data=Data; </span><br><span class="line">            t-&gt;Right-&gt;Left=t-&gt;Right-&gt;Right=<span class="literal">NULL</span>;</span><br><span class="line">            AddQ(Q,t-&gt;Right); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="求二叉树的高度"><a href="#求二叉树的高度" class="headerlink" title="求二叉树的高度"></a>求二叉树的高度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">GetHeight</span><span class="params">( BinTree BT )</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> HL, HR, MaxH;</span><br><span class="line">    <span class="keyword">if</span>( BT ) &#123;</span><br><span class="line">        HL = GetHeight(BT-&gt;Left);   <span class="comment">/* 求左子树的高度 */</span></span><br><span class="line">        HR = GetHeight(BT-&gt;Right);  <span class="comment">/* 求右子树的高度 */</span></span><br><span class="line">        MaxH = HL &gt; HR ? HL : HR;   <span class="comment">/* 取左右子树较大的高度 */</span></span><br><span class="line">        <span class="keyword">return</span> ( MaxH + <span class="number">1</span> );        <span class="comment">/* 返回树的高度 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* 空树高度为0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二元运算表达式树及其遍历"><a href="#二元运算表达式树及其遍历" class="headerlink" title="二元运算表达式树及其遍历"></a>二元运算表达式树及其遍历</h4><p>中缀表达式会受到运算符优先级的影响</p>
<p>中缀转后缀(先转换完表达式)用的原则是遇到的运算符的优先级大于等于栈里的运算符时，该运算符入栈<br>读到运算符，从堆栈中弹出两个元素，构成新的二叉树，并将指向它的指针压栈<br>更多例题参看P124图4.23</p>
<h4 id="由两种遍历序列确定二叉树"><a href="#由两种遍历序列确定二叉树" class="headerlink" title="由两种遍历序列确定二叉树"></a>由两种遍历序列确定二叉树</h4><p><strong>必须要有中序遍历才行！</strong><br>先序遍历序列的第一个结点就是根结点；<br>这个根结点能够<strong>在中序遍历序列中将其余结点分割成两个子序列</strong>。<br>在先序序列中找到对应的左子序列和右子序列，对应左子树和右子树。<br>然后分别递归使用相同的方法继续分解。</p>
<h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ol>
<li>遇到一个结点就把它压入栈；</li>
<li>沿着这个结点的左孩子，依次入栈，直到左孩子为空，说明已经找到可以输出的结点；</li>
<li>栈顶元素出栈并访问：若其右孩子为空，继续执行第3步，若其右孩子不空，将右子树转执行第1步；<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InorderTraversal</span><span class="params">( BinTree BT )</span> &#123;</span><br><span class="line">    BinTree T;</span><br><span class="line">    <span class="type">int</span> MaxSize;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入堆栈所容纳的最大值：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;MaxSize);</span><br><span class="line">    Stack S = CreateStack(MaxSize); <span class="comment">/* 创建空堆栈S，元素类型为BinTree*/</span></span><br><span class="line">    T = BT; <span class="comment">/* 从根结点出发 */</span></span><br><span class="line">    <span class="keyword">while</span>( T || !IsEmpty(S) )&#123;</span><br><span class="line">        <span class="keyword">while</span>( T )&#123;</span><br><span class="line">            Push(S, T); </span><br><span class="line">            T = T-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        T = Pop(S); <span class="comment">/* 结点弹出堆栈 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;Data);  <span class="comment">/*（访问）打印结点 */</span></span><br><span class="line">        T = T-&gt;Right; <span class="comment">/* 转向右子树 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4></li>
<li>从队列中取出一个元素；</li>
<li>访问该元素所指结点；</li>
<li>若该元素所指结点的左、右孩子结点非空，则将其左、右孩子的指针顺序入队。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelorderTraversal</span> <span class="params">( BinTree BT )</span> &#123;</span><br><span class="line">    Queue Q; 	</span><br><span class="line">    BinTree T;          </span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">if</span> ( !BT )   </span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">/* 若是空树则直接返回 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入队列的规模\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;size);</span><br><span class="line">    Q = CreatQueue(size); <span class="comment">/* 创建空队列Q */</span></span><br><span class="line">    AddQ( Q, BT );</span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        T = DeleteQ( Q );</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, T-&gt;Data); </span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Left )   AddQ( Q, T-&gt;Left );</span><br><span class="line">        <span class="keyword">if</span> ( T-&gt;Right )  AddQ( Q, T-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>话说回来，之前做层序遍历的时候，用java做了个递归方法的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   List&lt;List&lt;Integer&gt;&gt; List = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">level</span><span class="params">(TreeNode node,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(List.size()==level)&#123;</span><br><span class="line">           List.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">       &#125;</span><br><span class="line">       List.get(level).add(node.val);</span><br><span class="line">       <span class="keyword">if</span>(node.left!= <span class="literal">null</span>)level(node.left,level+<span class="number">1</span>);</span><br><span class="line">       <span class="keyword">if</span>(node.right!= <span class="literal">null</span>)level(node.right,level+<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">null</span>)<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       level(root,<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> List;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p>对我个人而言，这比队列的非递归算法好理解的多，不过这是因为java有list可以直接add()<br>对于c语言而言，要这样写必须要使用多重链表</p>
</blockquote>
</li>
</ol>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>“二叉搜索树（BST，Binary Search Tree）”也称二叉排序树或二叉查找树，它是一种对排序和查找都很有用的特殊二叉树。<br>它可以为空。如果不为空。</p>
<blockquote>
<p>它将满足以下性质：<br>非空左子树的所有键值小于其根结点的键值。<br>非空右子树的所有键值大于其根结点的键值。<br>左、右子树都是二叉搜索树。</p>
</blockquote>
<p>不可以有等于的值出现。</p>
<h3 id="动态查找"><a href="#动态查找" class="headerlink" title="动态查找"></a>动态查找</h3><p>查找x-&gt;非递归查找(快)<br>查找min/max-&gt;最左端/最右端</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST )&#123; <span class="comment">/*若原树为空，生成并返回一个结点的二叉搜索树*/</span></span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> TNode));</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 开始找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = Insert( BST-&gt;Left, X );</span><br><span class="line">            <span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = Insert( BST-&gt;Right, X ); </span><br><span class="line">            <span class="comment">/*递归插入右子树*/</span></span><br><span class="line">        <span class="comment">/* else X已经存在，什么都不做 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>搜索二叉树插入一定能插入到最下面。</strong></p>
<p>感觉上面那个算法不用递归直接迭代while(BST) BST=BST-&gt;Right就行，记录最后一个BST的值，出来的时候新生成tnode，让最后一个bst指向他，通过大小判断左/右。<br>…..这样想完以后感觉确实是递归简洁一些。</p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>要删除的结点有左、右两棵子树时，有两个选择：</p>
<ol>
<li>取右子树中的最小元素替代</li>
<li>取左子树中的最大元素替代</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span><br><span class="line">&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line">    <span class="keyword">if</span>( !BST ) <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = Delete( BST-&gt;Left, X ); <span class="comment">/*左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = Delete( BST-&gt;Right, X );<span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//x=bst-&gt;data,找到了</span></span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) &#123;</span><br><span class="line">                Tmp = FindMin( BST-&gt;Right ); <span class="comment">//取右子树的最小元素。</span></span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                BST-&gt;Right = Delete( BST-&gt;Right, BST-&gt;Data ); <span class="comment">//把最小的数放在删除的位置，然后去找最小数的位置删除。</span></span><br><span class="line">                <span class="comment">//并且由于搜索二叉树的性质，这个最小的节点一定在最底下，会由下面这个else情况进行链接。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//如果度为一/叶子节点，直接下一个节点上移。</span></span><br><span class="line">                Tmp = BST;       </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )   </span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>            </span><br><span class="line">                    BST = BST-&gt;Left; </span><br><span class="line">                <span class="built_in">free</span>( Tmp );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>查找<strong>二叉搜索树</strong>（BST）的时间复杂度（最坏情况下）用查找过程中的比较次数来衡量，<strong>它取决于树的<em>深度</em></strong>。<br>平均查找长度ASL<br>    假设二叉搜索树中每个结点的查找概率都是相同的，则查找所有结点的比较次数的平均值称为“平均查找长度”<br>ASL=∑(深度x节点个数)/节点总数</p>
<p><strong>平衡因子（Balance Factor，简称BF）</strong>：<strong>BF(T) = hL-hR</strong>(左-右)<br>其中hL和hR分别为T的左、右子树的高度。</p>
<p><strong>平衡二叉树（Balanced Binary Tree）AVL树(可以是空树)</strong><br>AVL数是<strong>二叉搜索树(BST)</strong>，任一结点左、右子树高度差的绝对值不超过1。<br>即|BF(T) |≤ 1。<br>给定结点数为 n的AVL树的最大高度为log2n+1，从而保证了AVL树的查找时间性能为O(log2n)<br><strong><em>最小</em>平衡二叉树的结点公式：F(n)=F(n-1)+F(n-2)+1</strong><br>其中n是avl的高度,+1是有一个节点连接了两边。</p>
<blockquote>
<p>【习题】若平衡二叉树的高度为6，且所有非叶子结点的平衡因子均为1，则该平衡二叉树的结点总数为</p>
</blockquote>
<h3 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h3><p>请看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1tZ421q72h/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2443f4ea7c585c3029ca642665fa2f8a">VCR</a><br>个人白话:</p>
<ol>
<li>哪边高度高作什么旋<ul>
<li>对于我校教材来说，x旋=x手螺旋的方向</li>
</ul>
</li>
<li>判断最下面的节点的位置在失衡节点x的孩子的y子树上<br>switch xy:<ul>
<li>RR 对失衡节点右旋</li>
<li>LL 对失衡节点左旋</li>
<li>RL 左旋右孩子，再对失衡节点右旋</li>
<li>LR 右旋左孩子，再对失衡节点左旋</li>
</ul>
</li>
<li>当x旋的位置有节点挡着时，这个节点成为旋转节点另一边的孩子。<ul>
<li>⚠️当没有节点挡着，不改变边连线。</li>
</ul>
</li>
</ol>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>优先队列（Priority Queue）</strong>从堆中取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。<br><strong>堆（Heap）</strong>:采用<strong>完全二叉树</strong>存储的优先队列。</p>
<ul>
<li>最大堆(MaxHeap):每个结点上的元素值不小于其子结点元素的值。</li>
<li>最小堆(MinHeap):任一结点的值小于<strong>或等于</strong>其子结点的值。</li>
<li>兄弟结点之间不存在约束关系<br>↑可以有相同的元素出现。</li>
</ul>
<p>特性：用<strong>数组</strong>表示的完全二叉树(起始单元为1)<br>堆在代码上并没有标志性的树结构，看上去只是数组操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">HNode</span> *<span class="title">Heap</span>;</span>  <span class="comment">/* 堆的类型定义 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">HNode</span> &#123;</span></span><br><span class="line">    ElementType *Data; <span class="comment">/* 存储元素的数组 */</span></span><br><span class="line">    <span class="type">int</span> Size;                       <span class="comment">/* 堆中当前元素个数 */</span></span><br><span class="line">    <span class="type">int</span> Capacity;               <span class="comment">/* 堆的最大容量 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> Heap MaxHeap;           <span class="comment">/* 最大堆 */</span></span><br><span class="line"><span class="keyword">typedef</span> Heap MinHeap;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MaxHeap <span class="title function_">CreateHeap</span><span class="params">( <span class="type">int</span>   MaxSize )</span></span><br><span class="line">&#123; <span class="comment">/* 创建容量为MaxSize的空的最大堆 */</span></span><br><span class="line">    MaxHeap H = (MaxHeap)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HNode));</span><br><span class="line">    H-&gt;Data = (ElementType *)<span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>)*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capacity = MaxSize;</span><br><span class="line">    H-&gt;Data[<span class="number">0</span>] = MAXDATA;<span class="comment">//这是&lt;哨兵&gt;</span></span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p>完全二叉树-&gt;最新节点的位置是固定的<br>用要插入元素向下过滤上层结点（相当于要插入的元素<strong>向上渗透</strong>）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">Insert</span><span class="params">( MaxHeap H, ElementType X )</span></span><br><span class="line">&#123; <span class="comment">/* 将元素X插入最大堆H，其中H-&gt;Data[0]已经定义为哨兵 */</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> ( IsFull(H) ) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已满&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size; </span><br><span class="line">    <span class="keyword">for</span> ( ; H-&gt;Data[i/<span class="number">2</span>] &lt; X; i/=<span class="number">2</span> )<span class="comment">//直到父节点大于x</span></span><br><span class="line">    <span class="comment">//哨兵=&gt;顶层元素可以被比较。</span></span><br><span class="line">        H-&gt;Data[i] = H-&gt;Data[i/<span class="number">2</span>]; <span class="comment">/* 上滤X */</span></span><br><span class="line">    H-&gt;Data[i] = X; <span class="comment">/* 将X插入 */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>T(N)=O(logn)</p>
<h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3><p><strong>向下渗透</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">DeleteMax</span><span class="params">( MaxHeap H )</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> Parent, Child;</span><br><span class="line">    ElementType MaxItem, X;</span><br><span class="line">    <span class="keyword">if</span> ( IsEmpty(H) ) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;最大堆已为空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxItem = H-&gt;Data[<span class="number">1</span>]; <span class="comment">/* 取出根结点存放的最大值 */</span></span><br><span class="line">    <span class="comment">/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */</span></span><br><span class="line">    X = H-&gt;Data[H-&gt;Size--]; <span class="comment">/* 注意当前堆的规模要减小 */</span></span><br><span class="line">    <span class="keyword">for</span>( Parent=<span class="number">1</span>; Parent*<span class="number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; </span><br><span class="line">           (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="number">1</span>]) )</span><br><span class="line">            Child++;  <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= H-&gt;Data[Child] ) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* 下滤X */</span></span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></p>
<h3 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h3><p>即如何将已经存在的N个元素按最大堆的要求存放在一个一维数组中。<br>方法一：将N个元素一个个相继插入到一个初始为空的堆中去，O(NlogN)<br>方法二：在线性时间复杂度下建立最大堆</p>
<ol>
<li>将N个元素按输入顺序存入二叉树中，这一步只要求满足完全二叉树的结构特性，而不管其有序性。</li>
<li>调整各结点元素，以满足最大堆的有序特性。 </li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PercDown</span><span class="params">( MaxHeap H, <span class="type">int</span> p )</span></span><br><span class="line">&#123;   <span class="type">int</span> Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line">    X = H-&gt;Data[p]; <span class="comment">/* 取出根结点存放的值 */</span></span><br><span class="line">    <span class="keyword">for</span>( Parent=p; Parent*<span class="number">2</span>&lt;=H-&gt;Size; Parent=Child ) &#123;</span><br><span class="line">        Child = Parent * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( (Child!=H-&gt;Size) &amp;&amp; (H-&gt;Data[Child]&lt;H-&gt;Data[Child+<span class="number">1</span>]) )</span><br><span class="line">            Child++;  <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= H-&gt;Data[Child] ) </span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">/* 下滤X */</span></span><br><span class="line">            H-&gt;Data[Parent] = H-&gt;Data[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Data[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">BuildHeap</span><span class="params">( MaxHeap H )</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/* 从最后一个结点的父节点开始，到根结点1 */</span></span><br><span class="line">    <span class="keyword">for</span>( i = H-&gt;Size/<span class="number">2</span>; i&gt;<span class="number">0</span>; i-- )</span><br><span class="line">        PercDown( H, i );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>T(N)=O(N)<br>每个perdown的比较次数只和那个节点的高度有关。远远达不到N<br><img src="../images/数据结构/image-6.png" alt="alt text"><br>虽然字丑但是简单易懂的证明↑</p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>带权路径长度（Weighted PathLength），简称WPL:<br>设一棵二叉树有n个叶子结点，每个叶子结点带有权值 wk，从根结点到每个叶子结点的长度为 lk，则每个叶子结点的带权路径长度之和就是这棵树的带权路径长度。<br><img src="../images/数据结构/image-7.png" alt="alt text"><br>达到WPL最小的二叉树就称为最优二叉树或哈夫曼树<br><strong>不唯一</strong>。左右子树互换就是不同的二叉树。</p>
<h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p>每次把权值最小的两棵二叉树合并<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HuffmanTree <span class="title function_">Huffman</span><span class="params">( MinHeap H )</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">int</span> i, N;</span><br><span class="line">    HuffmanTree T;</span><br><span class="line">    BuildHeap(H); <span class="comment">/* 将H-&gt;Data[ ]按权值Weight调整为最小堆 */</span></span><br><span class="line">    N = H-&gt;Size;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">1</span>; i&lt;N; i++ ) &#123; <span class="comment">/* 做H-&gt;Size-1次合并 */</span></span><br><span class="line">        T = (HuffmanTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HTNode)); </span><br><span class="line">        T-&gt;Left = DeleteMin(H);</span><br><span class="line">        T-&gt;Right = DeleteMin(H); </span><br><span class="line">        T-&gt;Weight = T-&gt;Left-&gt;Weight+T-&gt;Right-&gt;Weight; </span><br><span class="line">        Insert( H, T ); <span class="comment">/* 将新T插入最小堆 后调整为最小堆*/</span></span><br><span class="line">    &#125;	</span><br><span class="line">    <span class="keyword">return</span> DeleteMin(H);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>最上面的数字是总权重，不是wpl。<br>用堆是因为最大堆查找快。</p>
<p>哈夫曼树的特点：</p>
<ol>
<li>没有度为1的结点，因为构造方法导致的。</li>
<li>n个叶子结点的哈夫曼树共有2n-1个结点(n1=0)</li>
<li>哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树</li>
</ol>
<h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><p>所有字符都只出现在“满二叉树”(full tree)的叶子上时任何码串都可以无二义地解码–—— 这样的码叫做<strong>前缀码prefix code</strong>.<br>度为1-&gt;出现相同前缀</p>
<p>WPL计算的是边的数量</p>
<h2 id="集合及其运算"><a href="#集合及其运算" class="headerlink" title="集合及其运算"></a>集合及其运算</h2><p>这不是有向图吗<br>逻辑上，可以用树结构表示集合，树的每个结点代表一个集合元素。</p>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p><img src="../images/数据结构/image-8.png" alt="alt text"><br>G =（V,  E）。每条边是一个顶点对（v, w)∈ E ，并且 v, w ∈ V。</p>
<h2 id="图的定义和术语"><a href="#图的定义和术语" class="headerlink" title="图的定义和术语"></a>图的定义和术语</h2><p>看书吧！晕字了<br>有向边也称“<strong>弧</strong>（Arc）”<br>简单图（Simple Graphs）:没有重边和自回路的图。<br>简单路径：除了路径的首（ vp ）尾（ vq ）顶点外，vi1, vi2, ···, vin 都是不同顶点<br>回路：起点和终点相同（vp = vq ）的路径，简单路径形成的回路称为简单回路<br>无环图 ：不存在任何回路的图。<br><strong>有向无环图</strong> ::= 不存在回路的有向图，也称<strong>DAG</strong> （Directed Acyclic Graph）<br>无向<strong>完全图</strong>：在无向简单图中，任意两顶点都有一条边相连接<br>无向图的顶点连通、连通图、连通分量：<br>无向图中<strong>任意两顶点都是连通的</strong>，则称该图是“<strong>连通图</strong>（Connected Graph）”。<br>无向图的<strong>极大连通子图</strong>称为“<strong>连通分量（Connected Component）</strong>”。连通分量的概念包含以下4个要点：</p>
<ul>
<li>子图——连通分量是原图的子图</li>
<li>连通——连通分量本身是连通的</li>
<li><strong>极大顶点数——再加入其他顶点，将导致子图不连通</strong></li>
<li>极大边数——具有极大顶点数的连通子图，包含依附于这些顶点的所有边。<br>有向图中任意一对顶点vi 和vj (i≠j)均既有从vi到vj的路径，也有从vj到vi的路径，则称该有向图是“强连通图（Strongly Connected Graph）”。<br>有向图的极大强连通子图称为“强连通分量”。连通分量的概念也包含前面4个要点。<br>树是图的特例：无环的无向图。<br>所谓连通图G的“<strong>生成树</strong>（Spanning Tree）”，是G的包含其全部n 个顶点的一个<strong>极小连通子图</strong>。它必定包含且仅包含G的n-1条边。<br>生成森林：图的各棵生成树组成了一个图的生成森林。←这不就集合<br><strong>边的两倍是所有顶点的度之和</strong></li>
</ul>
<blockquote>
<p>关于无向连通图特性的描述中，正确的是（   ）<br>I.所有顶点的度之和为偶数<br>II.边数大于顶点个数减1<br>III.至少有一个顶点的度为1<br>A.只有I       B.只有II       C.I和II       D.I和III</p>
<p>具有6个顶点的无向图，当有（     ）条边时能确保是一个连通图。<br>A.10         B. 11           C. 13          D. 15</p>
</blockquote>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>S=O(|V|^2),确定有多少条边T=O(|V|^2)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535 <span class="comment">/* ∞设为65535*/</span></span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">GNode</span>  *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">GNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span>  Nv;  <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="type">int</span>  Ne;  <span class="comment">/* 边数   */</span></span><br><span class="line">    <span class="comment">/* 邻接矩阵 */</span></span><br><span class="line">    WeightType  G[MaxVertexNum][MaxVertexNum]; </span><br><span class="line">    DataType  Data[MaxVertexNum];      <span class="comment">/* 存顶点的数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>   PtrToGNode  MGraph; <span class="comment">/* 以邻接矩阵存储的图类型 */</span></span><br></pre></td></tr></table></figure><br>MGraph  CreateGraph( int  VertexNum )<br>初始化：e=0，e=infinity</p>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>  <span class="title">AdjVNode</span>   *<span class="title">PtrToAdjVNode</span>;</span> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AdjVNode</span>&#123;</span></span><br><span class="line">    Vertex   AdjV;		<span class="comment">/* 邻接点下标 */</span></span><br><span class="line">    WeightType  Weight;  <span class="comment">/* 边权重 */</span></span><br><span class="line">    PtrToAdjVNode  Next;   <span class="comment">/* 指向下一个邻接点的指针 */</span></span><br><span class="line">&#125;;<span class="comment">//这是链表节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Vnode</span>&#123;</span></span><br><span class="line">    PtrToAdjVNode   FirstEdge;<span class="comment">/* 边表头指针 */</span></span><br><span class="line">    DataType Data;	<span class="comment">/* 存顶点的数据 */</span></span><br><span class="line"><span class="comment">/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */</span></span><br><span class="line">&#125; AdjList[MaxVertexNum];    <span class="comment">/* AdjList是邻接表类型 */</span></span><br><span class="line"><span class="comment">//这是表头</span></span><br><span class="line"><span class="comment">//话说结构数组居然可以直接这样吗</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GNode</span> *<span class="title">PtrToGNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GNode</span>&#123;</span>  </span><br><span class="line">    <span class="type">int</span> Nv;     <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="type">int</span> Ne;     <span class="comment">/* 边数   */</span></span><br><span class="line">    AdjList G;  <span class="comment">/* 邻接表 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span>   PtrToGNode   LGraph; </span><br><span class="line"><span class="comment">/* 以邻接表方式存储的图类型 */</span> </span><br><span class="line"><span class="comment">//这是图本体</span></span><br></pre></td></tr></table></figure>
<p>初始化：表头=null<br>一个图的邻接矩阵表示<strong>唯一</strong>，邻接表表示不唯一<br>邻接表体现的是边的信息，和顶点无关</p>
<blockquote>
<p>若邻接表中有奇数个边表结点，则（     ）。<br>A.图中有奇数个结点           B.图中有偶数个结点<br>C.图为无向图                 D.图为有向图</p>
</blockquote>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h3 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h3><p>DFS<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">( Graph G, Vertex V, <span class="type">void</span> (*Vs)(Vertex) )</span></span><br><span class="line">&#123;   <span class="comment">/* 从第V个顶点出发递归地深度优先遍历图G */</span></span><br><span class="line">    (*Vs) ( V ); <span class="comment">/* 访问第V个顶点 */</span></span><br><span class="line">    Visited[V] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> ( V 的每个邻接点 W )</span><br><span class="line">    <span class="keyword">if</span> ( !Visited[W] )</span><br><span class="line">            <span class="comment">/* 对V的尚未访问的邻接顶点W递归调用DFS */</span></span><br><span class="line">        DFS( G, W, Visit );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void(*Vs)(Vertex v);</span></span><br><span class="line"><span class="comment">1，按运算符优先级， Vs 先与* 结合， 说明Vs是个指针</span></span><br><span class="line"><span class="comment">2，然后(*Vs) 与后面的 ()结合， 说明*Vs 是个函数</span></span><br><span class="line"><span class="comment">所以(*Vs)( )是个函数指针</span></span><br><span class="line"><span class="comment">...所以函数指针有屁用啊</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br>邻接矩阵T=O(|V|^2)<br>邻接表T=O(|V|+|E|)</p>
<h3 id="广度优先算法"><a href="#广度优先算法" class="headerlink" title="广度优先算法"></a>广度优先算法</h3><p>BFS<br>树的层数遍历的拓展，或者说层数遍历本来就是一种bfs<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFS</span> <span class="params">( MGraph Graph, Vertex S, <span class="type">void</span> (*Vs)(Vertex) )</span></span><br><span class="line">&#123;   <span class="comment">/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 */</span></span><br><span class="line">    Queue Q; 	</span><br><span class="line">    Vertex V, W;</span><br><span class="line">    Q = CreateQueue( MaxSize ); </span><br><span class="line">    <span class="comment">/* 访问顶点S：此处可根据具体访问需要改写 */</span></span><br><span class="line">    (*Vs) ( S );</span><br><span class="line">    Visited[S] = <span class="literal">true</span>; <span class="comment">/* 标记S已访问 */</span></span><br><span class="line">    AddQ(Q, S); <span class="comment">/* S入队列 */</span></span><br><span class="line">    <span class="keyword">while</span> ( !IsEmpty(Q) ) &#123;</span><br><span class="line">        V = DeleteQ(Q);  <span class="comment">/* 弹出V */</span></span><br><span class="line">        <span class="keyword">for</span>( W=<span class="number">0</span>; W&lt;Graph-&gt;Nv; W++ ) <span class="comment">/* 对图中的每个顶点W */</span></span><br><span class="line">            <span class="keyword">if</span> ( !Visited[W] &amp;&amp; IsEdge(Graph, V, W) ) &#123;</span><br><span class="line">                (*Vs) ( W ); <span class="comment">/* 访问顶点W */</span></span><br><span class="line">                Visited[W] = <span class="literal">true</span>; <span class="comment">/* 标记W已访问 */</span></span><br><span class="line">                AddQ(Q, W); <span class="comment">/* W入队列 */</span>     </span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实际上访问起点外面或者是在调用bfs/dfs时还要套一层循环，因为对于非连通图无法一次访问所有节点。</p>
<h2 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h2><p>dfs生成-&gt;前序遍历<br>bfs-&gt;层序遍历<br>最小生成树（Minimum Spanning Tree，简记为MST）</p>
<ul>
<li>最小生成树不是唯一的</li>
<li>当图G中的各边权值互不相等时，G的最小生成树是唯一的</li>
<li>最小生成树的边的权值之和总是唯一的，即最小</li>
<li>若无向连通图G的边数比顶点数少1，即G本身就是一棵树</li>
<li>最小生成树的边数为顶点数减1（树的性质</li>
</ul>
<h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><p>dist记录的是距离可连通节点的最短距离。<br>每次选择dist最小的点走。</p>
<p><img src="../images/数据结构/image-9.png" alt="alt text"></p>
<h3 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h3><ol>
<li>选择一条权重最小的边；</li>
<li>判定一条边的两端是否属于同一棵树；</li>
<li>合并两棵树</li>
</ol>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>单源最短路径（ Single-Source Shortest Path）问题就是从一个源点到其他各顶点的最短路径问题。</p>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><p>把prim算法的dist判定为dist[V]+Graph-&gt;G[V][W] &lt; dist[W] </p>
<p>每一对顶点之间的最短路径（ All-Pairs Shortest Path）<br>T=O(|V|^3)</p>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>形式上非常<em>简洁优雅</em>，对于比较稠密的图，实际运行效率更快</p>
<ol>
<li>逐个选择点vx</li>
<li>排除vx行列上所有元素</li>
<li>更新其他元素路径</li>
<li>循环以上步骤nv次</li>
</ol>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>“有向无环图”（Directed Acyclic Graph，简称DAG<br>拓扑排序是指有向无环图中各顶点构成的有序序列。该序列满足如下条件：如果图中一顶点vi到另一顶点vj存在一条路径，那么vj在此图的拓扑排序序列中位于vi之后。<br>理论依据：一个顶点数|V| &gt; 1的有向图，如果每个顶点的入度都大于0，那么它必定存在回路。</p>
<ol>
<li>如果找得到任何一个入度为0的顶点v，则step 2，否则step 4；</li>
<li>输出顶点v，并从图中删除该顶点以及与其相连的所有边；</li>
<li>对改变后的图重复这一过程，转step 1；</li>
<li>如果已经输出全部顶点，则结束；否则该有向图不是DAG。</li>
</ol>
<p>核心思想是用一个队列动态记录所有入度为0的顶点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略初始化indegree</span></span><br><span class="line">    <span class="keyword">for</span>(V=<span class="number">0</span>; V&lt;Graph-&gt;Nv; V++)                     </span><br><span class="line">        <span class="keyword">if</span> ( Indegree[V]==<span class="number">0</span> )  </span><br><span class="line">            AddQ(Q, V);   </span><br><span class="line">    cnt = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span>( !IsEmpty(Q) )&#123;</span><br><span class="line">        V = DeleteQ(Q); </span><br><span class="line">        TopOrder[cnt++] = V; </span><br><span class="line">        <span class="keyword">for</span>(W= Graph-&gt;G[V].FirstEdge; W; W=W-&gt;Next)</span><br><span class="line">            <span class="keyword">if</span> ( --Indegree[W] == <span class="number">0</span>)  AddQ(Q, W); </span><br><span class="line">    &#125; <span class="comment">/* while结束*/</span></span><br><span class="line">    <span class="keyword">if</span> ( cnt != Graph-&gt;Nv )     </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">/* 说明图中有回路 */</span> </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     <span class="comment">/* 拓扑排序结束*/</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h2><p><strong>AOV （Activity On Vertex）网络</strong> 是一个有向图 G ，其中V( G ) 表示活动 (比如课程) 、 E( G )表示领先关系( 比如课程  C1 先修于课程 C3 )。<br>一个“可行的” <strong>AOV 网络必须是DAG</strong>。否则图中有回路，从而就不能确定回路中的活动究竟哪个先实施。<br>改造图：</p>
<ol>
<li>所有顶点转换成边；</li>
<li>入度=1的顶点的入边转换成一个顶点；</li>
<li>入度&gt;1的顶点的入边转换成虚边(权值0)；</li>
<li>对入度&gt;1的顶点引入额外顶点(如6’)；</li>
<li>虚边指向额外顶点<br>简化方法：<br>对出度为1且出边的权重是0，则<strong>删去该顶点及其出边</strong></li>
</ol>
<ul>
<li>Earliest(v) 事件v (顶点v) 的最早完成时间<ul>
<li>Earliest(w) = <strong>MAX</strong>{ Earliest (v)  + Cv,w } </li>
<li><ul>
<li>从Earliest (0) = 0 开始向前递推</li>
</ul>
</li>
<li><strong>Earliest(n)工程完成的最早时间</strong></li>
</ul>
</li>
<li>Latest(w) 事件w的最晚完成时间 <ul>
<li>Latest (v) =  <strong>MIN</strong>{ Latest(w) -  Cv,w } </li>
<li><strong>Latest(n-1) = Earliest (n-1)开始向后递推</strong></li>
</ul>
</li>
<li>Delay v,w = Latest[w] - Earlieat[v] - Cv,w<br>  Delay v,w = 0 活动就是关键活动</li>
<li>由关键活动构成的最长路径叫关键路径-&gt;它的长度是工程完成时间max，所以下一题答案是B</li>
</ul>
<blockquote>
<p>【习题】若使用AOE网估算工程进度，则下列叙述中正确的是（        ）。<br>A关键路径是从源点到汇点边数最多的一条路径<br>B关键路径是从源点到汇点路径长度最长的路径<br>C增加任一关键活动的时间不会延长工程的工期<br>D缩短任一关键活动的时间将会缩短工程的工期<br>//存在多条关键路径时，缩短一条关键活动的时间不一定会缩短工程的工期，缩短了路径长度的那条关键路径不一定还是关键路径。</p>
</blockquote>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><img src="../images/数据结构/image-10.png" alt="alt text"></p>
<h2 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h2><p>在一组待排序记录中，如果存在任意两个相等的记录R和S，且在待排序记录中R在S前，如果在排序后R依然在S前，即它们的前后位置在排序前后不发生变化，则称该排序算法是稳定的。<br>意义：书11-25</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">( ElementType *a, ElementType *b )</span>&#123;</span><br><span class="line">     ElementType t = *a; *a = *b; *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">SimpleSelectionSort</span><span class="params">( ElementType A[ ], <span class="type">int</span> N )</span>&#123; </span><br><span class="line">    <span class="type">int</span> i, j, min;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N<span class="number">-1</span>; i++ ) &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> ( j=i+<span class="number">1</span>; j&lt;N; j++ )</span><br><span class="line">            <span class="keyword">if</span> ( A[j] &lt; A[min] )</span><br><span class="line">                min = j; </span><br><span class="line">    <span class="comment">/* 将第i个元素与最小元素交换 */</span></span><br><span class="line">        Swap( &amp;A[i],  &amp;A[min] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T(n) = O（n^2）<br>S(n) = O（1）<br>稳定性：不稳定</p>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>把最大堆堆顶元素元素放在最后，剩余的调整为最大堆，直到所有元素都被放置过。<br>先建最大堆-&gt;堆顶元素和堆的最后一个元素调换-&gt;从堆顶元素自上而下调整为最大堆<br>T(N)=O(NlogN)<br>S(n)=O(1) *只考虑新使用的空间，待排序数组的空间不计算。<br>稳定性：不稳定<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PercDown</span><span class="params">( ElementType A[], <span class="type">int</span> p, <span class="type">int</span> N )</span></span><br><span class="line">&#123;   <span class="type">int</span> Parent, Child;</span><br><span class="line">    ElementType X;</span><br><span class="line">    X = A[p]; <span class="comment">/* 取出根结点存放的值 */</span></span><br><span class="line">    <span class="keyword">for</span>( Parent=p; (Parent*<span class="number">2</span>+<span class="number">1</span>)&lt;N; Parent=Child ) &#123;</span><br><span class="line">    Child = Parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>( (Child!=N<span class="number">-1</span>) &amp;&amp; (A[Child]&lt;A[Child+<span class="number">1</span>]) )</span><br><span class="line">            Child++;  <span class="comment">/* Child指向左右子结点的较大者 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &gt;= A[Child] ) <span class="keyword">break</span>; <span class="comment">/* 找到了合适位置 */</span></span><br><span class="line">    <span class="keyword">else</span>  A[Parent] = A[Child];</span><br><span class="line">    &#125;</span><br><span class="line">    A[Parent] = X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：这里是*2+1，因为拿到的本质上是普通数组，序号从0开始而不是1.</span></span><br><span class="line"><span class="comment">//删除并不需要哨兵，因为是向下渗透。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">( ElementType A[], <span class="type">int</span> N )</span> </span><br><span class="line">&#123;   <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i=N/<span class="number">2</span><span class="number">-1</span>; i&gt;=<span class="number">0</span>; i-- )</span><br><span class="line">        PercDown( A, i, N );<span class="comment">//调整为最大堆     </span></span><br><span class="line">    <span class="keyword">for</span> ( i=N<span class="number">-1</span>; i&gt;<span class="number">0</span>; i-- ) &#123; </span><br><span class="line">        Swap( &amp;A[<span class="number">0</span>], &amp;A[i] );</span><br><span class="line">        PercDown( A, <span class="number">0</span>, i );<span class="comment">//剩余的i个元素调整为最大堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="简单插入排序"><a href="#简单插入排序" class="headerlink" title="简单插入排序"></a>简单插入排序</h3><p>将待排序的一组序列分为已排好序的和未排好序的两个部分<br>插入，不是<a href="#简单选择排序">交换</a><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertionSort</span><span class="params">( ElementType A[ ], <span class="type">int</span> N )</span></span><br><span class="line">&#123;    <span class="type">int</span>  P, i;</span><br><span class="line">     ElementType   Tmp;</span><br><span class="line">     <span class="keyword">for</span> ( P=<span class="number">1</span>; P&lt;N; P++ ) &#123;</span><br><span class="line">           Tmp = A[P]; </span><br><span class="line">           <span class="keyword">for</span> ( i=P; i&gt;<span class="number">0</span> &amp;&amp; A[i<span class="number">-1</span>]&gt;Tmp;  i-- )</span><br><span class="line"></span><br><span class="line">             A[i] = A[i<span class="number">-1</span>]; </span><br><span class="line">            A[i] = Tmp; <span class="comment">/* 放进合适的位置 */</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>T(N) = O(N^2)<br>S(n)=O(1)<br>稳定性：稳定</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>将待排序的一组元素按一定间隔分为若干序列，分别进行插入排序；开始时设置的“间隔”较大，在每轮排序中将间隔逐步减小，直到“间隔”为1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">( ElementType A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> Si, D, P, i;</span><br><span class="line">    ElementType Tmp;</span><br><span class="line">    <span class="type">int</span> Sedgewick[] = &#123;<span class="number">929</span>, <span class="number">505</span>, <span class="number">209</span>, <span class="number">109</span>, <span class="number">41</span>, <span class="number">19</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> ( Si=<span class="number">0</span>; Sedgewick[Si]&gt;=N; Si++ ); </span><br><span class="line">    <span class="keyword">for</span> ( D=Sedgewick[Si]; D&gt;<span class="number">0</span>; D=Sedgewick[++Si] )</span><br><span class="line">        <span class="keyword">for</span> ( P=D; P&lt;N; P++ ) &#123; </span><br><span class="line">            Tmp = A[P];</span><br><span class="line">            <span class="keyword">for</span> ( i=P; i&gt;=D &amp;&amp; A[i-D]&gt;Tmp; i-=D )</span><br><span class="line">                A[i] = A[i-D];</span><br><span class="line">            A[i] = Tmp;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>T(n) = O(N^2)<br>S(n) = O(1)<br>稳定性：不稳定<br>对初始基本有序的序列，可以提高时间性能。</p>
<h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">( ElementType A[ ], <span class="type">int</span> N )</span></span><br><span class="line">&#123;   <span class="type">int</span> P, i;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">for</span> ( P=N<span class="number">-1</span>; P&gt;<span class="number">0</span>; P-- ) &#123;</span><br><span class="line">          flag = <span class="literal">false</span>; </span><br><span class="line">          <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;P; i++ ) &#123; <span class="comment">/* 一趟冒泡 */</span></span><br><span class="line">       <span class="keyword">if</span> ( A[i] &gt; A[i+<span class="number">1</span>] ) &#123;</span><br><span class="line">        Swap( &amp;A[i], &amp;A[i+<span class="number">1</span>] ); </span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">/* 标识发生了交换 */</span></span><br><span class="line">      &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> ( flag==<span class="literal">false</span> )     <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>T(n) = O(N^2)<br>S(n) = O(1)<br>稳定性：稳定</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>选取一个基准点放在最后然后把小于这个数和大于这个数的放在两边。<br>再对两边进行递归。<br>为了避免最坏情形，确定基准时用“<strong>三者取其中</strong>”的方法，即将A[ low ]、A[ high ]、A[ ( low + high ) / 2 ]三者关键字的中值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ElementType <span class="title function_">Median3</span><span class="params">( ElementType A[ ], <span class="type">int</span> Left, <span class="type">int</span> Right )</span>&#123; </span><br><span class="line">    <span class="type">int</span> Center = (Left+Right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( A[Left] &gt; A[Center] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Center] );</span><br><span class="line">    <span class="keyword">if</span> ( A[Left] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Left], &amp;A[Right] );</span><br><span class="line">    <span class="keyword">if</span> ( A[Center] &gt; A[Right] )</span><br><span class="line">        Swap( &amp;A[Center], &amp;A[Right] );</span><br><span class="line">    Swap( &amp;A[Center], &amp;A[Right<span class="number">-1</span>] ); </span><br><span class="line">    <span class="comment">/* 只需要考虑A[Left+1] … A[Right-2] */</span></span><br><span class="line">    <span class="keyword">return</span>  A[Right<span class="number">-1</span>];  <span class="comment">/* 返回基准Pivot */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Qsort</span><span class="params">( ElementType A[], <span class="type">int</span> Left, <span class="type">int</span> Right )</span></span><br><span class="line">&#123;    </span><br><span class="line">    <span class="type">int</span> Pivot, Cutoff, Low, High;</span><br><span class="line">    <span class="keyword">if</span> ( Cutoff &lt;= Right-Left ) &#123; <span class="comment">/* 如果序列元素充分多，进入快排 */</span></span><br><span class="line">        Pivot = Median3( A, Left, Right ); <span class="comment">/* 选基准 */</span> </span><br><span class="line">        Low = Left; High = Right<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123; <span class="comment">/*将序列中比基准小的移到基准左边，大的移到右边*/</span></span><br><span class="line">            <span class="keyword">while</span> ( A[++Low] &lt; Pivot ) ;</span><br><span class="line">            <span class="keyword">while</span> ( A[--High] &gt; Pivot ) ;</span><br><span class="line">            <span class="keyword">if</span> ( Low &lt; High ) </span><br><span class="line">                Swap( &amp;A[Low], &amp;A[High] );</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Swap( &amp;A[Low], &amp;A[Right<span class="number">-1</span>] );   <span class="comment">/* 将基准换到正确的位置 */</span> </span><br><span class="line">        Qsort( A, Left, Low<span class="number">-1</span> );    <span class="comment">/* 递归解决左边 */</span> </span><br><span class="line">        Qsort( A, Low+<span class="number">1</span>, Right );   <span class="comment">/* 递归解决右边 */</span>  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> InsertionSort( A+Left, Right-Left+<span class="number">1</span> ); <span class="comment">/* 元素太少，用简单排序 */</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">( ElementType A[], <span class="type">int</span> N )</span></span><br><span class="line">&#123;   <span class="comment">/* 统一接口 */</span>     </span><br><span class="line">    Qsort( A, <span class="number">0</span>, N<span class="number">-1</span> );    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>T( N ) = T( i ) + T( N – i – 1 ) + c N</p>
<p><strong>T( N ) = O( N log N )</strong><br>由于快速排序需要进行至少log2N层的递归，因此需要至少O(log2N)深度的栈空间。<br>不稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将两个已排序的子序列合并成一个有序序列</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序的方法一般采用“主位优先法” ( Most Significant Digit First, MSD) 或者“次位优先法” ( Least Significant Digit First, LSD)</p>
<link rel="stylesheet" href="/css/folder.css" type="text/css"><script src="/js/folder.js" type="text/javascript" async></script>
    </article>
    <!-- license -->
    <!-- paginator -->
    <ul class="post-paginator">
        <li class="next">
                <div class="nextSlogan">Next Post</div>
                <a href="/posts/5751eea2.html" title="C++">
                    <div class="nextTitle">C++</div>
                </a>
        </li>
        <li class="previous">
                <div class="prevSlogan">Previous Post</div>
                <a href="/posts/33757.html" title="SSM">
                    <div class="prevTitle">SSM</div>
                </a>
        </li>
    </ul>
    <!-- comment -->
        <div class="post-comment">
            <!-- 来必力 City 版安装代码 -->

            
            
            
            <!-- utteranc评论 -->

            <!-- partial('_partial/comment/changyan') -->
            <!--PC版-->

            
            
            
        </div>
    <!-- timeliness note -->
    <!-- idea from: https://hexo.fluid-dev.com/posts/hexo-injector/#%E6%96%87%E7%AB%A0%E6%97%B6%E6%95%88%E6%80%A7%E6%8F%90%E7%A4%BA -->
    <!-- Mathjax -->
</main>

                <!-- profile -->
            </div>
            <footer class="footer footer-unloaded">
    <!-- social  -->
        <div class="social">
                            <a href="mailto:limiese0zen@gmail.com" class="iconfont-archer email" title="email" ></a>
                <a href="//github.com/zennnj" class="iconfont-archer github" target="_blank" title="github"></a>
                <a href="https://steamcommunity.com/profiles/76561199557415174" class="iconfont-archer steam" target="_blank" title="steam"></a>

        </div>
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- website approve for Chinese user -->
    <!-- 不蒜子  -->
        <div class="busuanzi-container">
                <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
        </div>
</footer>

        </div>
        <!-- toc -->
            <div class="toc-wrapper toc-wrapper-loding" style=    top:50vh;
>
                <div class="toc-catalog">
                    <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
                </div>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">线性结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-number">1.1.</span> <span class="toc-text">顺序表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E4%B9%89%E8%A1%A8%E4%B8%8E%E5%A4%9A%E9%87%8D%E9%93%BE%E8%A1%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">广义表与多重链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.3.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">堆栈的链式存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88%E5%BA%94%E7%94%A8%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="toc-number">1.3.2.</span> <span class="toc-text">堆栈应用：表达式求值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.4.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">队列的链式存储实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.4.2.</span> <span class="toc-text">双端队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">2.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.1.</span> <span class="toc-text">树的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%9C%AF%E8%AF%AD"><span class="toc-number">2.2.</span> <span class="toc-text">重要术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">二叉树存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.1.</span> <span class="toc-text">顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8"><span class="toc-number">2.5.2.</span> <span class="toc-text">链表存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.1.</span> <span class="toc-text">递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">创建二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">求二叉树的高度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%85%83%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E5%8F%8A%E5%85%B6%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.1.3.</span> <span class="toc-text">二元运算表达式树及其遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%B1%E4%B8%A4%E7%A7%8D%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E7%A1%AE%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.6.1.4.</span> <span class="toc-text">由两种遍历序列确定二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.2.</span> <span class="toc-text">非递归遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.2.1.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.6.2.2.</span> <span class="toc-text">层序遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">2.7.</span> <span class="toc-text">二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">2.7.1.</span> <span class="toc-text">动态查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">2.7.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">2.7.3.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.8.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E6%95%B4"><span class="toc-number">2.8.1.</span> <span class="toc-text">调整</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">2.9.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">2.9.1.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-1"><span class="toc-number">2.9.2.</span> <span class="toc-text">插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4-1"><span class="toc-number">2.9.3.</span> <span class="toc-text">删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B"><span class="toc-number">2.9.4.</span> <span class="toc-text">建立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">2.10.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">2.10.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">2.10.2.</span> <span class="toc-text">哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%8F%8A%E5%85%B6%E8%BF%90%E7%AE%97"><span class="toc-number">2.11.</span> <span class="toc-text">集合及其运算</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">3.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E6%9C%AF%E8%AF%AD"><span class="toc-number">3.1.</span> <span class="toc-text">图的定义和术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">3.3.</span> <span class="toc-text">邻接表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">3.4.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-number">3.4.1.</span> <span class="toc-text">深度优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.2.</span> <span class="toc-text">广度优先算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">3.5.</span> <span class="toc-text">生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.1.</span> <span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95"><span class="toc-number">3.5.2.</span> <span class="toc-text">Kruskal算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">3.6.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.1.</span> <span class="toc-text">Dijkstra算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="toc-number">3.6.2.</span> <span class="toc-text">Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">3.7.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">3.8.</span> <span class="toc-text">关键路径</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">4.1.</span> <span class="toc-text">排序算法的稳定性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.1.</span> <span class="toc-text">简单插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">4.3.2.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.2.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">4.4.4.</span> <span class="toc-text">基数排序</span></a></li></ol></li></ol></li></ol>
            </div>
        <!-- sidebar -->
        <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-archives">
    <!-- 在 ejs 中将 archive 按照时间排序 -->
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
    <div class="total-and-search">
        <div class="total-archive">
        Total : 24
        </div>
        <!-- search  -->
    </div>
    <div class="post-archive">
            <div class="archive-year"> 2077 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span>
            <a class="archive-post-title" href="/posts/8c0da805.html">「置顶」</a>
        </li>
                </ul>
            <div class="archive-year"> 2025 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">05/02</span>
            <a class="archive-post-title" href="/posts/4ee3286d.html">Maven构建问题</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/30</span>
            <a class="archive-post-title" href="/posts/bae4ff13.html">Redis</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">04/22</span>
            <a class="archive-post-title" href="/posts/da3e1361.html">Mybatis</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">03/08</span>
            <a class="archive-post-title" href="/posts/5751eea2.html">C++</a>
        </li>
                </ul>
            <div class="archive-year"> 2024 </div>
            <ul class="year-list">
        <li class="archive-post-item">
            <span class="archive-post-date">12/12</span>
            <a class="archive-post-title" href="/posts/79666db.html">数据结构</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/posts/33757.html">SSM</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span>
            <a class="archive-post-title" href="/posts/74add858.html">Git使用指南</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/09</span>
            <a class="archive-post-title" href="/posts/12634.html">本站使用的插件</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">11/03</span>
            <a class="archive-post-title" href="/posts/50460.html">做题记录串</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/26</span>
            <a class="archive-post-title" href="/posts/56743.html">unity</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/25</span>
            <a class="archive-post-title" href="/posts/59760.html">C#</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/19</span>
            <a class="archive-post-title" href="/posts/3629.html">编程细节记录</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">10/13</span>
            <a class="archive-post-title" href="/posts/58846.html">Java多线程</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span>
            <a class="archive-post-title" href="/posts/17374.html">JVM</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span>
            <a class="archive-post-title" href="/posts/9977.html">MySQL</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/40121.html">JAVA</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/41682.html">设计模式</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/7165.html">Github访问连接失败问题</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span>
            <a class="archive-post-title" href="/posts/28758.html">计算机网络</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span>
            <a class="archive-post-title" href="/posts/15691.html">Linux</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">09/10</span>
            <a class="archive-post-title" href="/posts/31602.html">后端</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">08/31</span>
            <a class="archive-post-title" href="/posts/12966.html">上学前的遗言</a>
        </li>
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span>
            <a class="archive-post-title" href="/posts/37559.html">个人用使用指南</a>
        </li>
            </ul>
    </div>
</div>

        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
            <span class="sidebar-tag-name" data-tags="learn">
                <span class="iconfont-archer">&#xe606;</span>
                learn
            </span>
            <span class="sidebar-tag-name" data-tags="problems">
                <span class="iconfont-archer">&#xe606;</span>
                problems
            </span>
            <span class="sidebar-tag-name" data-tags="practice">
                <span class="iconfont-archer">&#xe606;</span>
                practice
            </span>
            <span class="sidebar-tag-name" data-tags="碎碎念">
                <span class="iconfont-archer">&#xe606;</span>
                碎碎念
            </span>
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
        缺失模块，请参考主题文档进行安装配置：https://github.com/fi3ework/hexo-theme-archer#%E5%AE%89%E8%A3%85%E4%B8%BB%E9%A2%98
    </div> 
    <div class="sidebar-tags-list"></div>
</div>

        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
        <span class="sidebar-category-name" data-categories="JAVA">
            <span class="iconfont-archer">&#xe60a;</span>
            JAVA
        </span>
        <span class="sidebar-category-name" data-categories="记录">
            <span class="iconfont-archer">&#xe60a;</span>
            记录
        </span>
        <span class="sidebar-category-name" data-categories="数据库">
            <span class="iconfont-archer">&#xe60a;</span>
            数据库
        </span>
        <span class="sidebar-category-name" data-categories="unity">
            <span class="iconfont-archer">&#xe60a;</span>
            unity
        </span>
        <span class="sidebar-category-name" data-categories="框架">
            <span class="iconfont-archer">&#xe60a;</span>
            框架
        </span>
        <span class="sidebar-category-name" data-categories="计算机">
            <span class="iconfont-archer">&#xe60a;</span>
            计算机
        </span>
        <span class="sidebar-category-name" data-categories="secrets">
            <span class="iconfont-archer">&#xe60a;</span>
            secrets
        </span>
        <span class="sidebar-category-name" data-categories="use">
            <span class="iconfont-archer">&#xe60a;</span>
            use
        </span>
        <span class="sidebar-category-name" data-categories="chat">
            <span class="iconfont-archer">&#xe60a;</span>
            chat
        </span>
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>

    </div>
</div>

        <!-- site-meta -->
        <script>
    var siteMetaRoot = "/"
    if (siteMetaRoot === "undefined") {
        siteMetaRoot = '/'
    }
    var siteMeta = {
        url: "http://example.com",
        root: siteMetaRoot,
        author: ""
    }
</script>

        <!-- import experimental options here -->
        <!-- Custom Font -->

        <!-- main func -->
        <script src="/scripts/main.js"></script>
        <!-- fancybox -->
        <script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.36/dist/fancybox/fancybox.umd.js" onload="window.Fancybox.bind('[data-fancybox]')" defer></script>
        <!-- algolia -->
        <!-- busuanzi -->
            <script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script>
        <!-- async load share.js -->
            <script src="/scripts/share.js" async></script>
        <!-- mermaid -->
    <!-- hexo injector body_end start --><script src="https://fastly.jsdelivr.net/npm/hexo-tag-common@0.2.0/js/index.js"></script><!-- hexo injector body_end end --></body>
</html>
